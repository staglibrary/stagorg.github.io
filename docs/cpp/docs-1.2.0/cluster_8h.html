<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STAG C++: /home/runner/work/stag/stag/stag_lib/cluster.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ginger.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">STAG C++
   &#160;<span id="projectnumber">1.2.0</span>
   </div>
   <div id="projectbrief">Spectral Toolkit of Algorithms for Graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Check for latest docs version -->
    <script src="version.js"></script>
    <script>
        check_version("1.2.0");
    </script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KJQKRESXE4"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-KJQKRESXE4');
</script>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('cluster_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">cluster.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Algorithms for finding clusters in graphs. </p>
<p>The two key clustering methods provided by this module are <a class="el" href="cluster_8h.html#a92240a6d68323b538fd245077eb3e432">stag::spectral_cluster</a> and <a class="el" href="cluster_8h.html#aa95a665cefc95f9ff516ccce911a2892">stag::local_cluster</a>. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a92240a6d68323b538fd245077eb3e432"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#a92240a6d68323b538fd245077eb3e432">stag::spectral_cluster</a> (<a class="el" href="classstag_1_1Graph.html">stag::Graph</a> *graph, <a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a> k)</td></tr>
<tr class="separator:a92240a6d68323b538fd245077eb3e432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95a665cefc95f9ff516ccce911a2892"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#aa95a665cefc95f9ff516ccce911a2892">stag::local_cluster</a> (<a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *graph, <a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a> seed_vertex, double target_volume)</td></tr>
<tr class="separator:aa95a665cefc95f9ff516ccce911a2892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86a294bd0fc57a2ce251242ff41c454"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#af86a294bd0fc57a2ce251242ff41c454">stag::local_cluster_acl</a> (<a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *graph, <a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a> seed_vertex, double locality, double error)</td></tr>
<tr class="separator:af86a294bd0fc57a2ce251242ff41c454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aed6f2be1a504ed3de8b806f451884a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#a6aed6f2be1a504ed3de8b806f451884a">stag::local_cluster_acl</a> (<a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *graph, <a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a> seed_vertex, double locality)</td></tr>
<tr class="separator:a6aed6f2be1a504ed3de8b806f451884a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff04898668cea9bc9fa473fb7d491457"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="graph_8h.html#ae6a866d72ff20e19e40c84774c534375">SprsMat</a>, <a class="el" href="graph_8h.html#ae6a866d72ff20e19e40c84774c534375">SprsMat</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#aff04898668cea9bc9fa473fb7d491457">stag::approximate_pagerank</a> (<a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *graph, <a class="el" href="graph_8h.html#ae6a866d72ff20e19e40c84774c534375">SprsMat</a> &amp;seed_vector, double alpha, double epsilon)</td></tr>
<tr class="separator:aff04898668cea9bc9fa473fb7d491457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9556a1160d25765f67b6bc5a5b2cac35"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#a9556a1160d25765f67b6bc5a5b2cac35">stag::sweep_set_conductance</a> (<a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *graph, <a class="el" href="graph_8h.html#ae6a866d72ff20e19e40c84774c534375">SprsMat</a> &amp;vec)</td></tr>
<tr class="separator:a9556a1160d25765f67b6bc5a5b2cac35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7ce8f870ab46d7c7584534cbc925d4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#a1b7ce8f870ab46d7c7584534cbc925d4">stag::adjusted_rand_index</a> (std::vector&lt; <a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a> &gt; &amp;gt_labels, std::vector&lt; <a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a> &gt; &amp;labels)</td></tr>
<tr class="separator:a1b7ce8f870ab46d7c7584534cbc925d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208cda5596c6569bf098a03fbd1c5751"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#a208cda5596c6569bf098a03fbd1c5751">stag::conductance</a> (<a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *graph, std::vector&lt; <a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a> &gt; &amp;cluster)</td></tr>
<tr class="separator:a208cda5596c6569bf098a03fbd1c5751"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a92240a6d68323b538fd245077eb3e432" name="a92240a6d68323b538fd245077eb3e432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92240a6d68323b538fd245077eb3e432">&#9670;&#160;</a></span>spectral_cluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a> &gt; stag::spectral_cluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1Graph.html">stag::Graph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a>&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Spectral clustering algorithm.</p>
<p>This is a simple graph clustering method, which provides a clustering of the entire graph. To use spectral clustering, simply pass a <code><a class="el" href="classstag_1_1Graph.html" title="The core object used to represent graphs for use with the library.">stag::Graph</a></code> object and the number of clusters you would like to find.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stag/graph.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stag/cluster.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  <a class="code hl_class" href="classstag_1_1Graph.html">stag::Graph</a> myGraph = stag::barbell_graph(10);</div>
<div class="line">  std::vector&lt;stag_int&gt; clusters = stag::spectral_cluster(&amp;myGraph, 2);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> c : clusters) {</div>
<div class="line">    std::cout &lt;&lt; c &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassstag_1_1Graph_html"><div class="ttname"><a href="classstag_1_1Graph.html">stag::Graph</a></div><div class="ttdoc">The core object used to represent graphs for use with the library.</div><div class="ttdef"><b>Definition:</b> graph.h:169</div></div>
</div><!-- fragment --><p>The spectral clustering algorithm has the following steps.</p><ul>
<li>Compute the \(k\) smallest eigenvectors of the normalised Laplacian matrix.</li>
<li>Embed the vertices into \(\mathbb{R}^k\) according to the eigenvectors.</li>
<li>Cluster the vertices into \(k\) clusters using a \(k\)-means clustering algorithm.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>the graph object to be clustered </td></tr>
    <tr><td class="paramname">k</td><td>the number of clusters to find. Should be less than \(n/2\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector giving the cluster membership for each vertex in the graph</dd></dl>
<dl class="section user"><dt>References</dt><dd>A. Ng, M. Jordan, Y. Weiss. On spectral clustering: Analysis and an algorithm. NeurIPS'01 </dd></dl>

</div>
</div>
<a id="aa95a665cefc95f9ff516ccce911a2892" name="aa95a665cefc95f9ff516ccce911a2892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa95a665cefc95f9ff516ccce911a2892">&#9670;&#160;</a></span>local_cluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a> &gt; stag::local_cluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a>&#160;</td>
          <td class="paramname"><em>seed_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>target_volume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Local clustering algorithm based on personalised Pagerank.</p>
<p>Given a graph and starting vertex, return a cluster which is close to the starting vertex.</p>
<p>This method uses the ACL local clustering algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>a graph object implementing the LocalGraph interface </td></tr>
    <tr><td class="paramname">seed_vertex</td><td>the starting vertex in the graph </td></tr>
    <tr><td class="paramname">target_volume</td><td>the approximate volume of the cluster you would like to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the indices of vectors considered to be in the same cluster as the seed_vertex.</dd></dl>
<dl class="section user"><dt>References</dt><dd>R. Andersen, F. Chung, K. Lang. Local graph partitioning using pagerank vectors. FOCS'06 </dd></dl>

</div>
</div>
<a id="af86a294bd0fc57a2ce251242ff41c454" name="af86a294bd0fc57a2ce251242ff41c454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86a294bd0fc57a2ce251242ff41c454">&#9670;&#160;</a></span>local_cluster_acl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a> &gt; stag::local_cluster_acl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a>&#160;</td>
          <td class="paramname"><em>seed_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>locality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The ACL local clustering algorithm. Given a graph and starting vertex, return a cluster close to the starting vertex, constructed in a local way.</p>
<p>The locality parameter is passed as the alpha parameter in the personalised Pagerank calculation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>a graph object implementing the LocalGraph interface </td></tr>
    <tr><td class="paramname">seed_vertex</td><td>the starting vertex in the graph </td></tr>
    <tr><td class="paramname">locality</td><td>a value in \([0, 1]\) indicating how 'local' the cluster should be. A value of \(1\) will return only the seed vertex, and a value of \(0\) will explore the whole graph. </td></tr>
    <tr><td class="paramname">error</td><td>(optional) - the acceptable error in the calculation of the approximate pagerank. Default \(0.001\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the indices of vectors considered to be in the same cluster as the seed_vertex.</dd></dl>
<dl class="section user"><dt>References</dt><dd>R. Andersen, F. Chung, K. Lang. Local graph partitioning using pagerank vectors. FOCS'06 </dd></dl>

</div>
</div>
<a id="a6aed6f2be1a504ed3de8b806f451884a" name="a6aed6f2be1a504ed3de8b806f451884a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aed6f2be1a504ed3de8b806f451884a">&#9670;&#160;</a></span>local_cluster_acl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a> &gt; stag::local_cluster_acl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a>&#160;</td>
          <td class="paramname"><em>seed_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>locality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aff04898668cea9bc9fa473fb7d491457" name="aff04898668cea9bc9fa473fb7d491457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff04898668cea9bc9fa473fb7d491457">&#9670;&#160;</a></span>approximate_pagerank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="graph_8h.html#ae6a866d72ff20e19e40c84774c534375">SprsMat</a>, <a class="el" href="graph_8h.html#ae6a866d72ff20e19e40c84774c534375">SprsMat</a> &gt; stag::approximate_pagerank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="graph_8h.html#ae6a866d72ff20e19e40c84774c534375">SprsMat</a> &amp;&#160;</td>
          <td class="paramname"><em>seed_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the approximate Pagerank vector.</p>
<p>The parameters seed_vector, alpha, and epsilon are used as described in the ACL paper.</p>
<p>Note that the dimension of the returned vectors may not match the correct number of vertices in the graph provided since the approximate Pagerank is computed locally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>a <a class="el" href="classstag_1_1LocalGraph.html" title="An abstract class which defines methods for exploring the local neighborhood of vertices in a graph.">stag::LocalGraph</a> object </td></tr>
    <tr><td class="paramname">seed_vector</td><td>the seed vector of the personalised Pagerank </td></tr>
    <tr><td class="paramname">alpha</td><td>the locality parameter of the personalised Pagerank </td></tr>
    <tr><td class="paramname">epsilon</td><td>the error parameter of the personalised Pagerank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of sparse column vectors corresponding to<ul>
<li>p: the approximate Pagerank vector</li>
<li>r: the residual vector</li>
</ul>
</dd></dl>
<p>By the definition of approximate Pagerank, it holds that p + ppr(r, alpha) = ppr(s, alpha).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the provided seed_vector is not a column vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>References</dt><dd>R. Andersen, F. Chung, K. Lang. Local graph partitioning using pagerank vectors. FOCS'06 </dd></dl>

</div>
</div>
<a id="a9556a1160d25765f67b6bc5a5b2cac35" name="a9556a1160d25765f67b6bc5a5b2cac35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9556a1160d25765f67b6bc5a5b2cac35">&#9670;&#160;</a></span>sweep_set_conductance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a> &gt; stag::sweep_set_conductance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="graph_8h.html#ae6a866d72ff20e19e40c84774c534375">SprsMat</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the sweep set of the given vector with the minimum conductance.</p>
<p>First, sort the vector such that \(v_1&lt;= \ldots &lt;= v_n\). Then let</p>
<p class="formulaDsp">
\[
    S_i = \{v_j : j &lt;= i\}
\]
</p>
<p>and return the set of original indices corresponding to</p>
<p class="formulaDsp">
\[
    \mathrm{argmin}_i \phi(S_i)
\]
</p>
<p>where \(\phi(S)\) is the conductance of \(S\).</p>
<p>This method is expected to be run on vectors whose support is much less than the total size of the graph. If the total volume of the support of vec is larger than half of the volume of an entire graph, then this method may return unexpected results.</p>
<p>Note that the caller is responsible for any required normalisation of the input vector. In particular, this method does not normalise the vector by the node degrees.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>a <a class="el" href="classstag_1_1LocalGraph.html" title="An abstract class which defines methods for exploring the local neighborhood of vertices in a graph.">stag::LocalGraph</a> object </td></tr>
    <tr><td class="paramname">vec</td><td>the vector to sweep over </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the indices of vec which give the minimum conductance in the given graph </dd></dl>

</div>
</div>
<a id="a1b7ce8f870ab46d7c7584534cbc925d4" name="a1b7ce8f870ab46d7c7584534cbc925d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7ce8f870ab46d7c7584534cbc925d4">&#9670;&#160;</a></span>adjusted_rand_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stag::adjusted_rand_index </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>gt_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Adjusted Rand Index between two label vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gt_labels</td><td>the ground truth labels for the dataset </td></tr>
    <tr><td class="paramname">labels</td><td>the candidate labels whose ARI should be calculated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ARI between the two labels vectors</dd></dl>
<dl class="section user"><dt>References</dt><dd>W. M. Rand. Objective criteria for the evaluation of clustering methods. Journal of the American Statistical Association. 66 (336): 846â€“850. 1971. </dd></dl>

</div>
</div>
<a id="a208cda5596c6569bf098a03fbd1c5751" name="a208cda5596c6569bf098a03fbd1c5751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208cda5596c6569bf098a03fbd1c5751">&#9670;&#160;</a></span>conductance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stag::conductance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="graph_8h.html#a0c328014088200f0b1217356fad00372">stag_int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the conductance of the given cluster in a graph.</p>
<p>Given a graph \(G = (V, E)\), the conductance of \(S \subseteq V\) is defined to be</p>
<p class="formulaDsp">
\[
   \phi(S) = \frac{w(S, V \setminus S)}{\mathrm{vol}(S)},
\]
</p>
<p>where \(\mathrm{vol}(S) = \sum_{v \in S} \mathrm{deg}(v)\) is the volume of \(S\) and \(w(S, V \setminus S)\) is the total weight of edges crossing the cut between \(S\) and \(V \setminus S\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>a <a class="el" href="classstag_1_1LocalGraph.html" title="An abstract class which defines methods for exploring the local neighborhood of vertices in a graph.">stag::LocalGraph</a> object representing \(G\). </td></tr>
    <tr><td class="paramname">cluster</td><td>a vector of node IDs in \(S\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the conductance \(\phi_G(S)\). </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_ebbf4bb57fbd235b1eb4f1d2e773ae5e.html">stag_lib</a></li><li class="navelem"><a class="el" href="cluster_8h.html">cluster.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
