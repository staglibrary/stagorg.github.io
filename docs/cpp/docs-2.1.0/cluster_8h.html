<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STAG C++: /home/runner/work/stag/stag/stag_lib/cluster.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ginger.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">STAG C++
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
   <div id="projectbrief">Spectral Toolkit of Algorithms for Graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Check for latest docs version -->
    <script src="version.js"></script>
    <script>
        check_version("2.1.0");
    </script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KJQKRESXE4"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-KJQKRESXE4');
</script>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('cluster_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">cluster.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>Algorithms for finding clusters in graphs. </p>
<p>The methods in this module can be divided into three sub-categories.</p>
<dl class="section user"><dt>Clustering Algorithms</dt><dd>The two key clustering methods provided by this module are <a class="el" href="cluster_8h.html#aa017e566226f1dd329156c46441ce8be">stag::spectral_cluster</a> and <a class="el" href="cluster_8h.html#a4a7fc09fb36b2d2d0e3c570eff091c37">stag::local_cluster</a>.</dd></dl>
<dl class="section user"><dt>Similarity Graph Construction</dt><dd>The module provides the methods <a class="el" href="cluster_8h.html#af3b686a110f373b457771ca6a0455bbd">stag::similarity_graph</a> and <a class="el" href="cluster_8h.html#a5297de3416780152c282ac3918fc8d05">stag::approximate_similarity_graph</a> for constructing a similarity graph from data.</dd></dl>
<dl class="section user"><dt>Clustering Evaluation</dt><dd>The module provides implementations of the standard ARI and NMI clustering evaluation metrics in the <a class="el" href="cluster_8h.html#a37e08f74f0435510928298d29560c2cb">stag::adjusted_rand_index</a> and <a class="el" href="cluster_8h.html#a71fbd6a0c95b12f244f477779ad381b0">stag::normalised_mutual_information</a> methods. </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa017e566226f1dd329156c46441ce8be"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#aa017e566226f1dd329156c46441ce8be">stag::spectral_cluster</a> (<a class="el" href="classstag_1_1Graph.html">stag::Graph</a> *graph, <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> k)</td></tr>
<tr class="separator:aa017e566226f1dd329156c46441ce8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ec9679c04d4b1ec7b1c3be9b23c3a4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#a00ec9679c04d4b1ec7b1c3be9b23c3a4">stag::cheeger_cut</a> (<a class="el" href="classstag_1_1Graph.html">stag::Graph</a> *graph)</td></tr>
<tr class="separator:a00ec9679c04d4b1ec7b1c3be9b23c3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7fc09fb36b2d2d0e3c570eff091c37"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#a4a7fc09fb36b2d2d0e3c570eff091c37">stag::local_cluster</a> (<a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *graph, <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> seed_vertex, double target_volume)</td></tr>
<tr class="separator:a4a7fc09fb36b2d2d0e3c570eff091c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c7036bd606c60f19a0f4e743acc852"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#ad5c7036bd606c60f19a0f4e743acc852">stag::local_cluster_acl</a> (<a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *graph, <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> seed_vertex, double locality, double error)</td></tr>
<tr class="separator:ad5c7036bd606c60f19a0f4e743acc852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256223975a93b106d4f577385da418f7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#a256223975a93b106d4f577385da418f7">stag::local_cluster_acl</a> (<a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *graph, <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> seed_vertex, double locality)</td></tr>
<tr class="separator:a256223975a93b106d4f577385da418f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff04898668cea9bc9fa473fb7d491457"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="definitions_8h.html#a1ebaa6c875adf6fd0b374b5ca2c5476a">SprsMat</a>, <a class="el" href="definitions_8h.html#a1ebaa6c875adf6fd0b374b5ca2c5476a">SprsMat</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#aff04898668cea9bc9fa473fb7d491457">stag::approximate_pagerank</a> (<a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *graph, <a class="el" href="definitions_8h.html#a1ebaa6c875adf6fd0b374b5ca2c5476a">SprsMat</a> &amp;seed_vector, double alpha, double epsilon)</td></tr>
<tr class="separator:aff04898668cea9bc9fa473fb7d491457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e3cb3c9178851c097e1d915d43d0b6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#af7e3cb3c9178851c097e1d915d43d0b6">stag::sweep_set_conductance</a> (<a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *graph, <a class="el" href="definitions_8h.html#a1ebaa6c875adf6fd0b374b5ca2c5476a">SprsMat</a> &amp;vec)</td></tr>
<tr class="separator:af7e3cb3c9178851c097e1d915d43d0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70c08394051e1cabdf44a497b221a64"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#ac70c08394051e1cabdf44a497b221a64">stag::sweep_set_conductance</a> (<a class="el" href="classstag_1_1Graph.html">stag::Graph</a> *graph, <a class="el" href="definitions_8h.html#a1ebaa6c875adf6fd0b374b5ca2c5476a">SprsMat</a> &amp;vec)</td></tr>
<tr class="separator:ac70c08394051e1cabdf44a497b221a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2737eb0028ebc6da8ec13ccd457611"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#abe2737eb0028ebc6da8ec13ccd457611">stag::connected_component</a> (<a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *g, <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> v)</td></tr>
<tr class="separator:abe2737eb0028ebc6da8ec13ccd457611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357e8358e9ced1eaa73d03a804926af3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#a357e8358e9ced1eaa73d03a804926af3">stag::connected_components</a> (<a class="el" href="classstag_1_1Graph.html">stag::Graph</a> *g)</td></tr>
<tr class="separator:a357e8358e9ced1eaa73d03a804926af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e08f74f0435510928298d29560c2cb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#a37e08f74f0435510928298d29560c2cb">stag::adjusted_rand_index</a> (std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; &amp;gt_labels, std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; &amp;labels)</td></tr>
<tr class="separator:a37e08f74f0435510928298d29560c2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54cf40971427b45d2d3a904581a3d7c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#ac54cf40971427b45d2d3a904581a3d7c">stag::mutual_information</a> (std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; &amp;gt_labels, std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; &amp;labels)</td></tr>
<tr class="separator:ac54cf40971427b45d2d3a904581a3d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fbd6a0c95b12f244f477779ad381b0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#a71fbd6a0c95b12f244f477779ad381b0">stag::normalised_mutual_information</a> (std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; &amp;gt_labels, std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; &amp;labels)</td></tr>
<tr class="separator:a71fbd6a0c95b12f244f477779ad381b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842a790ef9ef6ef5f0fdc4fa0c78b015"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#a842a790ef9ef6ef5f0fdc4fa0c78b015">stag::conductance</a> (<a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *graph, std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; &amp;cluster)</td></tr>
<tr class="separator:a842a790ef9ef6ef5f0fdc4fa0c78b015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169df4b5c921ea6ece849c2d873951e2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#a169df4b5c921ea6ece849c2d873951e2">stag::symmetric_difference</a> (std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; &amp;S, std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; &amp;T)</td></tr>
<tr class="separator:a169df4b5c921ea6ece849c2d873951e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5297de3416780152c282ac3918fc8d05"><td class="memItemLeft" align="right" valign="top">Graph&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#a5297de3416780152c282ac3918fc8d05">stag::approximate_similarity_graph</a> (<a class="el" href="definitions_8h.html#a4d3b72d5ae8b2d1fc53b6a11c70dfd0d">DenseMat</a> *data, <a class="el" href="definitions_8h.html#a2b9ccdd280e2708de5771b2d4021d77e">StagReal</a> a, bool show_progress)</td></tr>
<tr class="separator:a5297de3416780152c282ac3918fc8d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbbc10c73add7054ecc8e79a60b8981"><td class="memItemLeft" align="right" valign="top">Graph&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#a4cbbc10c73add7054ecc8e79a60b8981">stag::approximate_similarity_graph</a> (<a class="el" href="definitions_8h.html#a4d3b72d5ae8b2d1fc53b6a11c70dfd0d">DenseMat</a> *data, <a class="el" href="definitions_8h.html#a2b9ccdd280e2708de5771b2d4021d77e">StagReal</a> a)</td></tr>
<tr class="separator:a4cbbc10c73add7054ecc8e79a60b8981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b686a110f373b457771ca6a0455bbd"><td class="memItemLeft" align="right" valign="top">Graph&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cluster_8h.html#af3b686a110f373b457771ca6a0455bbd">stag::similarity_graph</a> (<a class="el" href="definitions_8h.html#a4d3b72d5ae8b2d1fc53b6a11c70dfd0d">DenseMat</a> *data, <a class="el" href="definitions_8h.html#a2b9ccdd280e2708de5771b2d4021d77e">StagReal</a> a)</td></tr>
<tr class="separator:af3b686a110f373b457771ca6a0455bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa017e566226f1dd329156c46441ce8be" name="aa017e566226f1dd329156c46441ce8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa017e566226f1dd329156c46441ce8be">&#9670;&#160;</a></span>spectral_cluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; stag::spectral_cluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1Graph.html">stag::Graph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a>&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Spectral clustering algorithm.</p>
<p>This is a simple graph clustering method, which provides a clustering of the entire graph. To use spectral clustering, simply pass a <code><a class="el" href="classstag_1_1Graph.html" title="The core object used to represent graphs for use with the library.">stag::Graph</a></code> object and the number of clusters you would like to find.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stag/graph.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stag/cluster.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">  <a class="code hl_class" href="classstag_1_1Graph.html">stag::Graph</a> myGraph = stag::barbell_graph(10);</div>
<div class="line">  std::vector&lt;StagInt&gt; clusters = stag::spectral_cluster(&amp;myGraph, 2);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> c : clusters) {</div>
<div class="line">    std::cout &lt;&lt; c &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassstag_1_1Graph_html"><div class="ttname"><a href="classstag_1_1Graph.html">stag::Graph</a></div><div class="ttdoc">The core object used to represent graphs for use with the library.</div><div class="ttdef"><b>Definition:</b> graph.h:139</div></div>
</div><!-- fragment --><p>The spectral clustering algorithm has the following steps.</p><ul>
<li>Compute the \(k\) smallest eigenvectors of the normalised Laplacian matrix.</li>
<li>Embed the vertices into \(\mathbb{R}^k\) according to the eigenvectors.</li>
<li>Cluster the vertices into \(k\) clusters using a \(k\)-means clustering algorithm.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>the graph object to be clustered </td></tr>
    <tr><td class="paramname">k</td><td>the number of clusters to find. Should be less than \(n/2\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector giving the cluster membership for each vertex in the graph</dd></dl>
<dl class="section user"><dt>References</dt><dd>A. Ng, M. Jordan, Y. Weiss. On spectral clustering: Analysis and an algorithm. NeurIPS'01 </dd></dl>

</div>
</div>
<a id="a00ec9679c04d4b1ec7b1c3be9b23c3a4" name="a00ec9679c04d4b1ec7b1c3be9b23c3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ec9679c04d4b1ec7b1c3be9b23c3a4">&#9670;&#160;</a></span>cheeger_cut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; stag::cheeger_cut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1Graph.html">stag::Graph</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the Cheeger cut in a graph.</p>
<p>Let \(G = (V, E)\) be a graph and \(\mathcal{L}\) be its normalised Laplacian matrix with eigenvalues \(0 = \lambda_1 \leq \lambda_2 \leq \ldots \leq \lambda_n\). Then, Cheeger's inequality states that</p>
<p class="formulaDsp">
\[
  \frac{\lambda_2}{2} \leq \Phi_G \leq \sqrt{2 \lambda_2},
\]
</p>
<p>where</p>
<p class="formulaDsp">
\[
   \Phi_G = \min_{S \subset V} \phi(S)
\]
</p>
<p>is the conductance of \(G\). The proof of Cheeger's inequality is constructive: by computing the eigenvector corresponding to \(\lambda_2\), and performing the sweep set operation, we are able to find a set \(S\) with conductance close to the optimal. The partition returned by this algorithm is called the 'Cheeger cut' of the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>the graph object to be partitioned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector giving the cluster membership for each vertex in the graph. Each entry in the vector is either \(0\) or \(1\) to indicate which side of the cut the vertex belongs to. </dd></dl>

</div>
</div>
<a id="a4a7fc09fb36b2d2d0e3c570eff091c37" name="a4a7fc09fb36b2d2d0e3c570eff091c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7fc09fb36b2d2d0e3c570eff091c37">&#9670;&#160;</a></span>local_cluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; stag::local_cluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a>&#160;</td>
          <td class="paramname"><em>seed_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>target_volume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Local clustering algorithm based on personalised Pagerank.</p>
<p>Given a graph and starting vertex, return a cluster which is close to the starting vertex.</p>
<p>This method uses the ACL local clustering algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>a graph object implementing the LocalGraph interface </td></tr>
    <tr><td class="paramname">seed_vertex</td><td>the starting vertex in the graph </td></tr>
    <tr><td class="paramname">target_volume</td><td>the approximate volume of the cluster you would like to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the indices of vectors considered to be in the same cluster as the seed_vertex.</dd></dl>
<dl class="section user"><dt>References</dt><dd>R. Andersen, F. Chung, K. Lang. Local graph partitioning using pagerank vectors. FOCS'06 </dd></dl>

</div>
</div>
<a id="ad5c7036bd606c60f19a0f4e743acc852" name="ad5c7036bd606c60f19a0f4e743acc852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c7036bd606c60f19a0f4e743acc852">&#9670;&#160;</a></span>local_cluster_acl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; stag::local_cluster_acl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a>&#160;</td>
          <td class="paramname"><em>seed_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>locality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The ACL local clustering algorithm. Given a graph and starting vertex, return a cluster close to the starting vertex, constructed in a local way.</p>
<p>The locality parameter is passed as the alpha parameter in the personalised Pagerank calculation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>a graph object implementing the LocalGraph interface </td></tr>
    <tr><td class="paramname">seed_vertex</td><td>the starting vertex in the graph </td></tr>
    <tr><td class="paramname">locality</td><td>a value in \([0, 1]\) indicating how 'local' the cluster should be. A value of \(1\) will return only the seed vertex, and a value of \(0\) will explore the whole graph. </td></tr>
    <tr><td class="paramname">error</td><td>(optional) - the acceptable error in the calculation of the approximate pagerank. Default \(0.001\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the indices of vectors considered to be in the same cluster as the seed_vertex.</dd></dl>
<dl class="section user"><dt>References</dt><dd>R. Andersen, F. Chung, K. Lang. Local graph partitioning using pagerank vectors. FOCS'06 </dd></dl>

</div>
</div>
<a id="a256223975a93b106d4f577385da418f7" name="a256223975a93b106d4f577385da418f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256223975a93b106d4f577385da418f7">&#9670;&#160;</a></span>local_cluster_acl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; stag::local_cluster_acl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a>&#160;</td>
          <td class="paramname"><em>seed_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>locality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="aff04898668cea9bc9fa473fb7d491457" name="aff04898668cea9bc9fa473fb7d491457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff04898668cea9bc9fa473fb7d491457">&#9670;&#160;</a></span>approximate_pagerank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="definitions_8h.html#a1ebaa6c875adf6fd0b374b5ca2c5476a">SprsMat</a>, <a class="el" href="definitions_8h.html#a1ebaa6c875adf6fd0b374b5ca2c5476a">SprsMat</a> &gt; stag::approximate_pagerank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="definitions_8h.html#a1ebaa6c875adf6fd0b374b5ca2c5476a">SprsMat</a> &amp;&#160;</td>
          <td class="paramname"><em>seed_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the approximate Pagerank vector.</p>
<p>The parameters seed_vector, alpha, and epsilon are used as described in the ACL paper.</p>
<p>Note that the dimension of the returned vectors may not match the correct number of vertices in the graph provided since the approximate Pagerank is computed locally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>a <a class="el" href="classstag_1_1LocalGraph.html" title="An abstract class which defines methods for exploring the local neighborhood of vertices in a graph.">stag::LocalGraph</a> object </td></tr>
    <tr><td class="paramname">seed_vector</td><td>the seed vector of the personalised Pagerank </td></tr>
    <tr><td class="paramname">alpha</td><td>the locality parameter of the personalised Pagerank </td></tr>
    <tr><td class="paramname">epsilon</td><td>the error parameter of the personalised Pagerank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of sparse column vectors corresponding to<ul>
<li>p: the approximate Pagerank vector</li>
<li>r: the residual vector</li>
</ul>
</dd></dl>
<p>By the definition of approximate Pagerank, it holds that p + ppr(r, alpha) = ppr(s, alpha).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the provided seed_vector is not a column vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>References</dt><dd>R. Andersen, F. Chung, K. Lang. Local graph partitioning using pagerank vectors. FOCS'06 </dd></dl>

</div>
</div>
<a id="af7e3cb3c9178851c097e1d915d43d0b6" name="af7e3cb3c9178851c097e1d915d43d0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e3cb3c9178851c097e1d915d43d0b6">&#9670;&#160;</a></span>sweep_set_conductance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; stag::sweep_set_conductance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="definitions_8h.html#a1ebaa6c875adf6fd0b374b5ca2c5476a">SprsMat</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the sweep set of the given vector with the minimum conductance.</p>
<p>First, sort the vector such that \(v_1&lt;= \ldots &lt;= v_n\). Then let</p>
<p class="formulaDsp">
\[
    S_i = \{v_j : j &lt;= i\}
\]
</p>
<p>and return the set of original indices corresponding to</p>
<p class="formulaDsp">
\[
    \mathrm{argmin}_i \phi(S_i)
\]
</p>
<p>where \(\phi(S)\) is the conductance of \(S\).</p>
<p>When the provided graph is a <a class="el" href="classstag_1_1LocalGraph.html" title="An abstract class which defines methods for exploring the local neighborhood of vertices in a graph.">stag::LocalGraph</a>, the volume of the support of the provided vector should be less than half the total volume of the graph. The method does not (and cannot) check this condition.</p>
<p>When the provided graph is a <a class="el" href="classstag_1_1Graph.html" title="The core object used to represent graphs for use with the library.">stag::Graph</a>, there is no restriction on the volume of the support of the provided vector.</p>
<p>Note that the caller is responsible for any required normalisation of the input vector. In particular, this method does not normalise the vector by the node degrees.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>a <a class="el" href="classstag_1_1LocalGraph.html" title="An abstract class which defines methods for exploring the local neighborhood of vertices in a graph.">stag::LocalGraph</a> or <a class="el" href="classstag_1_1Graph.html" title="The core object used to represent graphs for use with the library.">stag::Graph</a> object </td></tr>
    <tr><td class="paramname">vec</td><td>the vector to sweep over </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the indices of vec which give the minimum conductance in the given graph </dd></dl>

</div>
</div>
<a id="ac70c08394051e1cabdf44a497b221a64" name="ac70c08394051e1cabdf44a497b221a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70c08394051e1cabdf44a497b221a64">&#9670;&#160;</a></span>sweep_set_conductance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; stag::sweep_set_conductance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1Graph.html">stag::Graph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="definitions_8h.html#a1ebaa6c875adf6fd0b374b5ca2c5476a">SprsMat</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="abe2737eb0028ebc6da8ec13ccd457611" name="abe2737eb0028ebc6da8ec13ccd457611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe2737eb0028ebc6da8ec13ccd457611">&#9670;&#160;</a></span>connected_component()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; stag::connected_component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the vertex indices of every vertex in the same connected component as the specified vertex.</p>
<p>The running time of this method is proportional to the size of the returned connected component.</p>
<p>The returned vector is not sorted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>a <a class="el" href="classstag_1_1LocalGraph.html" title="An abstract class which defines methods for exploring the local neighborhood of vertices in a graph.">stag::LocalGraph</a> instance </td></tr>
    <tr><td class="paramname">v</td><td>a vertex of the graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the vertex ids of every vertex in the connected component corresponding to v </dd></dl>

</div>
</div>
<a id="a357e8358e9ced1eaa73d03a804926af3" name="a357e8358e9ced1eaa73d03a804926af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357e8358e9ced1eaa73d03a804926af3">&#9670;&#160;</a></span>connected_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; &gt; stag::connected_components </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1Graph.html">stag::Graph</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a vector of the connected components in the specified graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>a <a class="el" href="classstag_1_1Graph.html" title="The core object used to represent graphs for use with the library.">stag::Graph</a> instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the connected components of the graph </dd></dl>

</div>
</div>
<a id="a37e08f74f0435510928298d29560c2cb" name="a37e08f74f0435510928298d29560c2cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e08f74f0435510928298d29560c2cb">&#9670;&#160;</a></span>adjusted_rand_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stag::adjusted_rand_index </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>gt_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Adjusted Rand Index between two label vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gt_labels</td><td>the ground truth labels for the dataset </td></tr>
    <tr><td class="paramname">labels</td><td>the candidate labels whose ARI should be calculated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ARI between the two labels vectors</dd></dl>
<dl class="section user"><dt>References</dt><dd>W. M. Rand. Objective criteria for the evaluation of clustering methods. Journal of the American Statistical Association. 66 (336): 846–850. 1971. </dd></dl>

</div>
</div>
<a id="ac54cf40971427b45d2d3a904581a3d7c" name="ac54cf40971427b45d2d3a904581a3d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54cf40971427b45d2d3a904581a3d7c">&#9670;&#160;</a></span>mutual_information()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stag::mutual_information </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>gt_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Mutual Information between two label vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gt_labels</td><td>the ground truth labels for the dataset </td></tr>
    <tr><td class="paramname">labels</td><td>the candidate labels whose MI should be calculated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the MI between the two labels vectors </dd></dl>

</div>
</div>
<a id="a71fbd6a0c95b12f244f477779ad381b0" name="a71fbd6a0c95b12f244f477779ad381b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71fbd6a0c95b12f244f477779ad381b0">&#9670;&#160;</a></span>normalised_mutual_information()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stag::normalised_mutual_information </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>gt_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Normalised Mutual Information between two label vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gt_labels</td><td>the ground truth labels for the dataset </td></tr>
    <tr><td class="paramname">labels</td><td>the candidate labels whose NMI should be calculated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the NMI between the two labels vectors</dd></dl>
<dl class="section user"><dt>References</dt><dd>Vinh, Epps, and Bailey, (2009). Information theoretic measures for clusterings comparison. 26th Annual International Conference on Machine Learning (ICML ‘09). </dd></dl>

</div>
</div>
<a id="a842a790ef9ef6ef5f0fdc4fa0c78b015" name="a842a790ef9ef6ef5f0fdc4fa0c78b015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842a790ef9ef6ef5f0fdc4fa0c78b015">&#9670;&#160;</a></span>conductance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double stag::conductance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1LocalGraph.html">stag::LocalGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the conductance of the given cluster in a graph.</p>
<p>Given a graph \(G = (V, E)\), the conductance of \(S \subseteq V\) is defined to be</p>
<p class="formulaDsp">
\[
   \phi(S) = \frac{w(S, V \setminus S)}{\mathrm{vol}(S)},
\]
</p>
<p>where \(\mathrm{vol}(S) = \sum_{v \in S} \mathrm{deg}(v)\) is the volume of \(S\) and \(w(S, V \setminus S)\) is the total weight of edges crossing the cut between \(S\) and \(V \setminus S\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>a <a class="el" href="classstag_1_1LocalGraph.html" title="An abstract class which defines methods for exploring the local neighborhood of vertices in a graph.">stag::LocalGraph</a> object representing \(G\). </td></tr>
    <tr><td class="paramname">cluster</td><td>a vector of node IDs in \(S\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the conductance \(\phi_G(S)\). </dd></dl>

</div>
</div>
<a id="a169df4b5c921ea6ece849c2d873951e2" name="a169df4b5c921ea6ece849c2d873951e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169df4b5c921ea6ece849c2d873951e2">&#9670;&#160;</a></span>symmetric_difference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; stag::symmetric_difference </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="definitions_8h.html#a71d9e7b56a1d77f9a154c09fbed3b451">StagInt</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the symmetric difference of two sets of integers.</p>
<p>Given sets \(S\) and \(T\), the symmetric difference \(S \triangle T\) is defined to be</p>
<p class="formulaDsp">
\[
   S \triangle T = \{S \setminus T\} \cup \{T \setminus S\}.
\]
</p>
<p>Although \(S\) and \(T\) are provided as vectors, they are treated as sets and any duplicates will be ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>a vector containing the first set of integers </td></tr>
    <tr><td class="paramname">T</td><td>a vector containing the second set of integers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the integers in the symmetric difference of S and T. </dd></dl>

</div>
</div>
<a id="a5297de3416780152c282ac3918fc8d05" name="a5297de3416780152c282ac3918fc8d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5297de3416780152c282ac3918fc8d05">&#9670;&#160;</a></span>approximate_similarity_graph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph stag::approximate_similarity_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="definitions_8h.html#a4d3b72d5ae8b2d1fc53b6a11c70dfd0d">DenseMat</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="definitions_8h.html#a2b9ccdd280e2708de5771b2d4021d77e">StagReal</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an approximate similarity graph for the given dataset.</p>
<p>Given datapoints \(\{x_1, \ldots, x_n\} \in \mathbb{R}^n\) and a parameter \(a\), the similarity between two data points is given by  </p><p class="formulaDsp">
\[
   k(x_i, x_j) = \mathrm{exp}\left(- a \|x_i - x_j\|^2 \right).
\]
</p>
<p> Then, the similarity graph of the data is a complete graph on \(n\) vertices such that the weight between vertex \(i\) and \(j\) is given by \(k(x_i, x_j)\). However, the complete similarity graph requires \(O(n^2)\) time and space to construct.</p>
<p>This method implements an algorithm which approximates the similarity graph with a sparse graph, while preserving any cluster structure of the graph. This algorithm has running time \(\widetilde{O}(n^{1.25})\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>an \(n \times d\) Eigen matrix representing the dataset. </td></tr>
    <tr><td class="paramname">a</td><td>the parameter of the similarity kernel. </td></tr>
    <tr><td class="paramname">show_progress</td><td>(optional) whether to show a progress bar when constructing the graph. Default: false. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classstag_1_1Graph.html" title="The core object used to represent graphs for use with the library.">stag::Graph</a> object representing the similarity of the data</dd></dl>
<dl class="section user"><dt>Reference</dt><dd>Peter Macgregor and He Sun, Fast Approximation of Similarity Graphs with Kernel Density Estimation. In NeurIPS'23. </dd></dl>

</div>
</div>
<a id="a4cbbc10c73add7054ecc8e79a60b8981" name="a4cbbc10c73add7054ecc8e79a60b8981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cbbc10c73add7054ecc8e79a60b8981">&#9670;&#160;</a></span>approximate_similarity_graph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph stag::approximate_similarity_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="definitions_8h.html#a4d3b72d5ae8b2d1fc53b6a11c70dfd0d">DenseMat</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="definitions_8h.html#a2b9ccdd280e2708de5771b2d4021d77e">StagReal</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="af3b686a110f373b457771ca6a0455bbd" name="af3b686a110f373b457771ca6a0455bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3b686a110f373b457771ca6a0455bbd">&#9670;&#160;</a></span>similarity_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Graph stag::similarity_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="definitions_8h.html#a4d3b72d5ae8b2d1fc53b6a11c70dfd0d">DenseMat</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="definitions_8h.html#a2b9ccdd280e2708de5771b2d4021d77e">StagReal</a>&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a complete similarity graph for the given dataset.</p>
<p>Given datapoints \(\{x_1, \ldots, x_n\} \in \mathbb{R}^n\) and a parameter \(a\), the similarity between two data points is given by  </p><p class="formulaDsp">
\[
   k(x_i, x_j) = \mathrm{exp}\left(- a \|x_i - x_j\|^2 \right).
\]
</p>
<p> Then, the similarity graph of the data is a complete graph on \(n\) vertices such that the weight between vertex \(i\) and \(j\) is given by \(k(x_i, x_j)\).</p>
<p>Note that the time and space complexity of this method is \(O(n^2)\). For a faster, approximate method, you could consider using <a class="el" href="cluster_8h.html#a5297de3416780152c282ac3918fc8d05">stag::approximate_similarity_graph</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>an \(n \times d\) Eigen matrix representing the dataset. </td></tr>
    <tr><td class="paramname">a</td><td>the parameter of the similarity kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classstag_1_1Graph.html" title="The core object used to represent graphs for use with the library.">stag::Graph</a> object representing the similarity of the data </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_ebbf4bb57fbd235b1eb4f1d2e773ae5e.html">stag_lib</a></li><li class="navelem"><a class="el" href="cluster_8h.html">cluster.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
