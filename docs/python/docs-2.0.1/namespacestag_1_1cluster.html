<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STAG Python: stag.cluster Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ginger.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">STAG Python
   &#160;<span id="projectnumber">2.0.1</span>
   </div>
   <div id="projectbrief">Spectral Toolkit of Algorithms for Graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
    <!-- Check for latest docs version -->
    <script src="version.js"></script>
    <script>
        check_version("2.0.1")
    </script>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KJQKRESXE4"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-KJQKRESXE4');
</script>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacestag_1_1cluster.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">stag.cluster Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a16a0a8a02435fcd1acfc0d94ec334ab2"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestag_1_1cluster.html#a16a0a8a02435fcd1acfc0d94ec334ab2">spectral_cluster</a> (<a class="el" href="classstag_1_1graph_1_1Graph.html">graph.Graph</a> g, int k)</td></tr>
<tr class="memdesc:a16a0a8a02435fcd1acfc0d94ec334ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spectral clustering algorithm.  <br /></td></tr>
<tr class="separator:a16a0a8a02435fcd1acfc0d94ec334ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fdaad88c310a9be5daa03e91c7ecb7"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestag_1_1cluster.html#ab8fdaad88c310a9be5daa03e91c7ecb7">cheeger_cut</a> (<a class="el" href="classstag_1_1graph_1_1Graph.html">graph.Graph</a> g)</td></tr>
<tr class="memdesc:ab8fdaad88c310a9be5daa03e91c7ecb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the Cheeger cut in a graph.  <br /></td></tr>
<tr class="separator:ab8fdaad88c310a9be5daa03e91c7ecb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10ddceee17f6f43018f20d13195a603"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestag_1_1cluster.html#aa10ddceee17f6f43018f20d13195a603">local_cluster</a> (<a class="el" href="classstag_1_1graph_1_1LocalGraph.html">graph.LocalGraph</a> g, int seed_vertex, float target_volume)</td></tr>
<tr class="memdesc:aa10ddceee17f6f43018f20d13195a603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Local clustering algorithm based on personalised Pagerank.  <br /></td></tr>
<tr class="separator:aa10ddceee17f6f43018f20d13195a603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac25c2f9daaa4cbbfe6fd31c157f1c7c"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestag_1_1cluster.html#aac25c2f9daaa4cbbfe6fd31c157f1c7c">local_cluster_acl</a> (<a class="el" href="classstag_1_1graph_1_1LocalGraph.html">graph.LocalGraph</a> g, int seed_vertex, float locality, float error=0.001)</td></tr>
<tr class="memdesc:aac25c2f9daaa4cbbfe6fd31c157f1c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ACL local clustering algorithm.  <br /></td></tr>
<tr class="separator:aac25c2f9daaa4cbbfe6fd31c157f1c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642f5836cd8ddb86040e4c1966fd56a9"><td class="memItemLeft" align="right" valign="top">Tuple[<a class="el" href="classstag_1_1utility_1_1SprsMat.html">utility.SprsMat</a>, <a class="el" href="classstag_1_1utility_1_1SprsMat.html">utility.SprsMat</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestag_1_1cluster.html#a642f5836cd8ddb86040e4c1966fd56a9">approximate_pagerank</a> (<a class="el" href="classstag_1_1graph_1_1LocalGraph.html">graph.LocalGraph</a> g, <a class="el" href="classstag_1_1utility_1_1SprsMat.html">utility.SprsMat</a> seed_vector, float alpha, float epsilon)</td></tr>
<tr class="memdesc:a642f5836cd8ddb86040e4c1966fd56a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the approximate pagerank vector.  <br /></td></tr>
<tr class="separator:a642f5836cd8ddb86040e4c1966fd56a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1a25bf548d5922cf0c5c821a65528b"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestag_1_1cluster.html#aad1a25bf548d5922cf0c5c821a65528b">sweep_set_conductance</a> (<a class="el" href="classstag_1_1graph_1_1LocalGraph.html">graph.LocalGraph</a> g, <a class="el" href="classstag_1_1utility_1_1SprsMat.html">utility.SprsMat</a> v)</td></tr>
<tr class="memdesc:aad1a25bf548d5922cf0c5c821a65528b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the sweep set of the given vector with the minimum conductance.  <br /></td></tr>
<tr class="separator:aad1a25bf548d5922cf0c5c821a65528b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fdcc8e8b61b7ebdc0f60c0f8faac27"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestag_1_1cluster.html#a41fdcc8e8b61b7ebdc0f60c0f8faac27">connected_component</a> (<a class="el" href="classstag_1_1graph_1_1LocalGraph.html">graph.LocalGraph</a> g, int v)</td></tr>
<tr class="memdesc:a41fdcc8e8b61b7ebdc0f60c0f8faac27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vertex indices of every vertex in the same connected component as the specified vertex.  <br /></td></tr>
<tr class="separator:a41fdcc8e8b61b7ebdc0f60c0f8faac27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221f10beed38ad81734318cdc537d68a"><td class="memItemLeft" align="right" valign="top">List[np.ndarray]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestag_1_1cluster.html#a221f10beed38ad81734318cdc537d68a">connected_components</a> (<a class="el" href="classstag_1_1graph_1_1Graph.html">graph.Graph</a> g)</td></tr>
<tr class="memdesc:a221f10beed38ad81734318cdc537d68a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of the connected components in the specified graph.  <br /></td></tr>
<tr class="separator:a221f10beed38ad81734318cdc537d68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a32c51da0d6ce14f68c134b9c2ca13"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestag_1_1cluster.html#af5a32c51da0d6ce14f68c134b9c2ca13">adjusted_rand_index</a> (np.ndarray gt_labels, np.ndarray labels)</td></tr>
<tr class="memdesc:af5a32c51da0d6ce14f68c134b9c2ca13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Adjusted Rand Index between two label vectors.  <br /></td></tr>
<tr class="separator:af5a32c51da0d6ce14f68c134b9c2ca13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf955ce8b8cb169edc02a08f58eb279"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestag_1_1cluster.html#a7bf955ce8b8cb169edc02a08f58eb279">mutual_information</a> (np.ndarray gt_labels, np.ndarray labels)</td></tr>
<tr class="memdesc:a7bf955ce8b8cb169edc02a08f58eb279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Mutual Information between two label vectors.  <br /></td></tr>
<tr class="separator:a7bf955ce8b8cb169edc02a08f58eb279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b038412cdb8018abbd486c005818c5b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestag_1_1cluster.html#a6b038412cdb8018abbd486c005818c5b">normalised_mutual_information</a> (np.ndarray gt_labels, np.ndarray labels)</td></tr>
<tr class="memdesc:a6b038412cdb8018abbd486c005818c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Normalised Mutual Information between two label vectors.  <br /></td></tr>
<tr class="separator:a6b038412cdb8018abbd486c005818c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b51bb68edc44e20dc32bdd6a719a4fe"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestag_1_1cluster.html#a0b51bb68edc44e20dc32bdd6a719a4fe">conductance</a> (<a class="el" href="classstag_1_1graph_1_1LocalGraph.html">graph.LocalGraph</a> g, np.ndarray cluster)</td></tr>
<tr class="memdesc:a0b51bb68edc44e20dc32bdd6a719a4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the conductance of the given cluster in a graph.  <br /></td></tr>
<tr class="separator:a0b51bb68edc44e20dc32bdd6a719a4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3375da3d31fffb4ce66f95e049d5b2"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestag_1_1cluster.html#a0f3375da3d31fffb4ce66f95e049d5b2">symmetric_difference</a> (np.ndarray s, np.ndarray t)</td></tr>
<tr class="memdesc:a0f3375da3d31fffb4ce66f95e049d5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the symmetric difference of two sets of integers.  <br /></td></tr>
<tr class="separator:a0f3375da3d31fffb4ce66f95e049d5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d975a0703c35ab431dac155d897ad2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstag_1_1graph_1_1Graph.html">graph.Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestag_1_1cluster.html#a30d975a0703c35ab431dac155d897ad2">approximate_similarity_graph</a> (<a class="el" href="classstag_1_1utility_1_1DenseMat.html">utility.DenseMat</a> data, float a)</td></tr>
<tr class="memdesc:a30d975a0703c35ab431dac155d897ad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an approximate similarity graph for the given dataset.  <br /></td></tr>
<tr class="separator:a30d975a0703c35ab431dac155d897ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a164cd3751f58aad7f66d21c359d93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstag_1_1graph_1_1Graph.html">graph.Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestag_1_1cluster.html#a32a164cd3751f58aad7f66d21c359d93">similarity_graph</a> (<a class="el" href="classstag_1_1utility_1_1DenseMat.html">utility.DenseMat</a> data, float a)</td></tr>
<tr class="memdesc:a32a164cd3751f58aad7f66d21c359d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a complete similarity graph for the given dataset.  <br /></td></tr>
<tr class="separator:a32a164cd3751f58aad7f66d21c359d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a16a0a8a02435fcd1acfc0d94ec334ab2" name="a16a0a8a02435fcd1acfc0d94ec334ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a0a8a02435fcd1acfc0d94ec334ab2">&#9670;&#160;</a></span>spectral_cluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray stag.cluster.spectral_cluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1graph_1_1Graph.html">graph.Graph</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spectral clustering algorithm. </p>
<p>This is a simple graph clustering method, which provides a clustering of the entire graph. To use spectral clustering, simply pass a <code><a class="el" href="classstag_1_1graph_1_1Graph.html" title="The core object used to represent graphs for use with the library.">stag.graph.Graph</a></code> object and the number of clusters you would like to find.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> <a class="code hl_namespace" href="namespacestag_1_1graph.html">stag.graph</a></div>
<div class="line"><span class="keyword">import</span> <a class="code hl_namespace" href="namespacestag_1_1cluster.html">stag.cluster</a></div>
<div class="line"> </div>
<div class="line">myGraph = stag.graph.Graph.barbell_graph(10)</div>
<div class="line">labels = <a class="code hl_function" href="namespacestag_1_1cluster.html#a16a0a8a02435fcd1acfc0d94ec334ab2">stag.cluster.spectral_cluster</a>(myGraph, 2)</div>
<div class="line">print(labels)</div>
<div class="ttc" id="anamespacestag_1_1cluster_html"><div class="ttname"><a href="namespacestag_1_1cluster.html">stag.cluster</a></div><div class="ttdef"><b>Definition:</b> cluster.py:1</div></div>
<div class="ttc" id="anamespacestag_1_1cluster_html_a16a0a8a02435fcd1acfc0d94ec334ab2"><div class="ttname"><a href="namespacestag_1_1cluster.html#a16a0a8a02435fcd1acfc0d94ec334ab2">stag.cluster.spectral_cluster</a></div><div class="ttdeci">np.ndarray spectral_cluster(graph.Graph g, int k)</div><div class="ttdoc">Spectral clustering algorithm.</div><div class="ttdef"><b>Definition:</b> cluster.py:39</div></div>
<div class="ttc" id="anamespacestag_1_1graph_html"><div class="ttname"><a href="namespacestag_1_1graph.html">stag.graph</a></div><div class="ttdef"><b>Definition:</b> graph.py:1</div></div>
</div><!-- fragment --><p>The spectral clustering algorithm has the following steps.</p><ul>
<li>Compute the \(k\) smallest eigenvectors of the normalised Laplacian matrix.</li>
<li>Embed the vertices into \(\mathbb{R}^k\) according to the eigenvectors.</li>
<li>Cluster the vertices into \(k\) clusters using a \(k\)-means clustering algorithm.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>the graph object to be clustered </td></tr>
    <tr><td class="paramname">k</td><td>the number of clusters to find. Should be less than \(n/2\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array ints giving the cluster membership for each vertex in the graph</dd></dl>
<dl class="section user"><dt>References</dt><dd>A. Ng, M. Jordan, Y. Weiss. On spectral clustering: Analysis and an algorithm. NeurIPS'01 </dd></dl>

</div>
</div>
<a id="ab8fdaad88c310a9be5daa03e91c7ecb7" name="ab8fdaad88c310a9be5daa03e91c7ecb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8fdaad88c310a9be5daa03e91c7ecb7">&#9670;&#160;</a></span>cheeger_cut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray stag.cluster.cheeger_cut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1graph_1_1Graph.html">graph.Graph</a>&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the Cheeger cut in a graph. </p>
<p>Let \(G = (V, E)\) be a graph and \(\mathcal{L}\) be its normalised Laplacian matrix with eigenvalues \(0 = \lambda_1 \leq \lambda_2 \leq \ldots \leq \lambda_n\). Then, Cheeger's inequality states that</p>
<p class="formulaDsp">
\[
      \frac{\lambda_2}{2} \leq \Phi_G \leq \sqrt{2 \lambda_2},
    \]
</p>
<p>where</p>
<p class="formulaDsp">
\[
       \Phi_G = \min_{S \subset V} \phi(S)
    \]
</p>
<p>is the conductance of \(G\). The proof of Cheeger's inequality is constructive: by computing the eigenvector corresponding to \(\lambda_2\), and performing the sweep set operation, we are able to find a set \(S\) with conductance close to the optimal. The partition returned by this algorithm is called the 'Cheeger cut' of the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>the graph object to be partitioned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array giving the cluster membership for each vertex in the graph. Each entry in the array is either \(0\) or \(1\) to indicate which side of the cut the vertex belongs to. </dd></dl>

</div>
</div>
<a id="aa10ddceee17f6f43018f20d13195a603" name="aa10ddceee17f6f43018f20d13195a603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10ddceee17f6f43018f20d13195a603">&#9670;&#160;</a></span>local_cluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray stag.cluster.local_cluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1graph_1_1LocalGraph.html">graph.LocalGraph</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>target_volume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Local clustering algorithm based on personalised Pagerank. </p>
<p>Given a graph and starting vertex, return a cluster which is close to the starting vertex.</p>
<p>This method uses the ACL local clustering algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>a graph object implementing the LocalGraph interface </td></tr>
    <tr><td class="paramname">seed_vertex</td><td>the starting vertex in the graph </td></tr>
    <tr><td class="paramname">target_volume</td><td>the approximate volume of the cluster you would like to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array containing the indices of vertices considered to be in the same cluster as the seed_vertex.</dd></dl>
<dl class="section user"><dt>References</dt><dd>R. Andersen, F. Chung, K. Lang. Local graph partitioning using pagerank vectors. FOCS'06 </dd></dl>

</div>
</div>
<a id="aac25c2f9daaa4cbbfe6fd31c157f1c7c" name="aac25c2f9daaa4cbbfe6fd31c157f1c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac25c2f9daaa4cbbfe6fd31c157f1c7c">&#9670;&#160;</a></span>local_cluster_acl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray stag.cluster.local_cluster_acl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1graph_1_1LocalGraph.html">graph.LocalGraph</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seed_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>locality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &#160;</td>
          <td class="paramname"><em>error</em> = <code>0.001</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The ACL local clustering algorithm. </p>
<p>Given a graph and starting vertex, returns a cluster close to the starting vertex, constructed in a local way.</p>
<p>The locality parameter is passed as the alpha parameter in the personalised pagerank calculation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>a graph object implementing the LocalGraph interface </td></tr>
    <tr><td class="paramname">seed_vertex</td><td>the starting vertex in the graph </td></tr>
    <tr><td class="paramname">locality</td><td>a value in \([0, 1]\) indicating how 'local' the cluster should be. A value of \(1\) will return the return only the seed vertex and a value of \(0\) will explore the whole graph. </td></tr>
    <tr><td class="paramname">error</td><td>(optional) - the acceptable error in the calculation of the approximate pagerank. Default \(0.001\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array containing the indices of vertices considered to be in the same cluster as the seed_vertex.</dd></dl>
<dl class="section user"><dt>References</dt><dd>R. Andersen, F. Chung, K. Lang. Local graph partitioning using pagerank vectors. FOCS'06 </dd></dl>

</div>
</div>
<a id="a642f5836cd8ddb86040e4c1966fd56a9" name="a642f5836cd8ddb86040e4c1966fd56a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642f5836cd8ddb86040e4c1966fd56a9">&#9670;&#160;</a></span>approximate_pagerank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Tuple[<a class="el" href="classstag_1_1utility_1_1SprsMat.html">utility.SprsMat</a>,
                                                  <a class="el" href="classstag_1_1utility_1_1SprsMat.html">utility.SprsMat</a>] stag.cluster.approximate_pagerank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1graph_1_1LocalGraph.html">graph.LocalGraph</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstag_1_1utility_1_1SprsMat.html">utility.SprsMat</a>&#160;</td>
          <td class="paramname"><em>seed_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>epsilon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the approximate pagerank vector. </p>
<p>The parameters s, alpha, and epsilon are used as described in the ACL paper.</p>
<p>Note that the dimension of the returned vectors may not match the true number of vertices in the graph provided since the approximate pagerank is computed locally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>a <a class="el" href="classstag_1_1graph_1_1LocalGraph.html" title="An abstract class which defines methods for exploring the local neighborhood of vertices in a graph.">stag.graph.LocalGraph</a> object </td></tr>
    <tr><td class="paramname">seed_vector</td><td>the seed vector of the personalised pagerank </td></tr>
    <tr><td class="paramname">alpha</td><td>the locality parameter of the personalised pagerank </td></tr>
    <tr><td class="paramname">epsilon</td><td>the error parameter of the personalised pagerank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple of sparse column vectors corresponding to<ul>
<li>p: the approximate pagerank vector</li>
<li>r: the residual vector</li>
</ul>
</dd></dl>
<p>By the definition of approximate pagerank, it is the case that p + ppr(r, alpha) = ppr(s, alpha).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">argument_error</td><td>if the provided seed_vector is not a column vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>References</dt><dd>R. Andersen, F. Chung, K. Lang. Local graph partitioning using pagerank vectors. FOCS'06 </dd></dl>

</div>
</div>
<a id="aad1a25bf548d5922cf0c5c821a65528b" name="aad1a25bf548d5922cf0c5c821a65528b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1a25bf548d5922cf0c5c821a65528b">&#9670;&#160;</a></span>sweep_set_conductance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray stag.cluster.sweep_set_conductance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1graph_1_1LocalGraph.html">graph.LocalGraph</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classstag_1_1utility_1_1SprsMat.html">utility.SprsMat</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the sweep set of the given vector with the minimum conductance. </p>
<p>First, sort the vector such that \(v_1, \ldots, v_n\). Then let</p>
<p class="formulaDsp">
\[
        S_i = \{v_j : j &lt;= i\}
    \]
</p>
<p>and return the set of original indices corresponding to</p>
<p class="formulaDsp">
\[
        \mathrm{argmin}_i \phi(S_i)
    \]
</p>
<p>where \(\phi(S)\) is the conductance of \(S\).</p>
<p>This method is expected to be run on vectors whose support is much less than the total size of the graph. If the total volume of the support of vec is larger than half of the volume of the total graph, then this method may return unexpected results.</p>
<p>Note that the caller is responsible for any required normalisation of the input vector. In particular, this method does not normalise the vector by the node degrees.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>a <a class="el" href="classstag_1_1graph_1_1LocalGraph.html" title="An abstract class which defines methods for exploring the local neighborhood of vertices in a graph.">stag.graph.LocalGraph</a> object </td></tr>
    <tr><td class="paramname">v</td><td>the vector to sweep over </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing the indices of vec which give the minimum conductance in the given graph </dd></dl>

</div>
</div>
<a id="a41fdcc8e8b61b7ebdc0f60c0f8faac27" name="a41fdcc8e8b61b7ebdc0f60c0f8faac27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41fdcc8e8b61b7ebdc0f60c0f8faac27">&#9670;&#160;</a></span>connected_component()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray stag.cluster.connected_component </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1graph_1_1LocalGraph.html">graph.LocalGraph</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the vertex indices of every vertex in the same connected component as the specified vertex. </p>
<p>The running time of this method is proportional to the size of the returned connected component.</p>
<p>The returned array is not sorted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>a <a class="el" href="classstag_1_1graph_1_1LocalGraph.html" title="An abstract class which defines methods for exploring the local neighborhood of vertices in a graph.">stag.graph.LocalGraph</a> object </td></tr>
    <tr><td class="paramname">v</td><td>a vertex of the graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array containing the vertex ids of every vertex in the connected component corresponding to v </dd></dl>

</div>
</div>
<a id="a221f10beed38ad81734318cdc537d68a" name="a221f10beed38ad81734318cdc537d68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221f10beed38ad81734318cdc537d68a">&#9670;&#160;</a></span>connected_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[np.ndarray] stag.cluster.connected_components </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1graph_1_1Graph.html">graph.Graph</a>&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of the connected components in the specified graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>a <a class="el" href="classstag_1_1graph_1_1Graph.html" title="The core object used to represent graphs for use with the library.">stag.graph.Graph</a> object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list containing the connected components of the graph </dd></dl>

</div>
</div>
<a id="af5a32c51da0d6ce14f68c134b9c2ca13" name="af5a32c51da0d6ce14f68c134b9c2ca13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a32c51da0d6ce14f68c134b9c2ca13">&#9670;&#160;</a></span>adjusted_rand_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> float stag.cluster.adjusted_rand_index </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>gt_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Adjusted Rand Index between two label vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gt_labels</td><td>the ground truth labels for the dataset </td></tr>
    <tr><td class="paramname">labels</td><td>the candidate labels whose ARI should be calculated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ARI between the two labels vectors</dd></dl>
<dl class="section user"><dt>References</dt><dd>W. M. Rand. Objective criteria for the evaluation of clustering methods. Journal of the American Statistical Association. 66 (336): 846–850. 1971. </dd></dl>

</div>
</div>
<a id="a7bf955ce8b8cb169edc02a08f58eb279" name="a7bf955ce8b8cb169edc02a08f58eb279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf955ce8b8cb169edc02a08f58eb279">&#9670;&#160;</a></span>mutual_information()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> float stag.cluster.mutual_information </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>gt_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Mutual Information between two label vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gt_labels</td><td>the ground truth labels for the dataset </td></tr>
    <tr><td class="paramname">labels</td><td>the candidate labels whose MI should be calculated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the MI between the two labels vectors </dd></dl>

</div>
</div>
<a id="a6b038412cdb8018abbd486c005818c5b" name="a6b038412cdb8018abbd486c005818c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b038412cdb8018abbd486c005818c5b">&#9670;&#160;</a></span>normalised_mutual_information()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> float stag.cluster.normalised_mutual_information </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>gt_labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Normalised Mutual Information between two label vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gt_labels</td><td>the ground truth labels for the dataset </td></tr>
    <tr><td class="paramname">labels</td><td>the candidate labels whose NMI should be calculated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the NMI between the two labels vectors</dd></dl>
<dl class="section user"><dt>References</dt><dd>Vinh, Epps, and Bailey, (2009). Information theoretic measures for clusterings comparison. 26th Annual International Conference on Machine Learning (ICML ‘09). </dd></dl>

</div>
</div>
<a id="a0b51bb68edc44e20dc32bdd6a719a4fe" name="a0b51bb68edc44e20dc32bdd6a719a4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b51bb68edc44e20dc32bdd6a719a4fe">&#9670;&#160;</a></span>conductance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> float stag.cluster.conductance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1graph_1_1LocalGraph.html">graph.LocalGraph</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>cluster</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the conductance of the given cluster in a graph. </p>
<p>Given a graph \(G = (V, E)\), the conductance of \(S \subseteq V\) is defined to be</p>
<p class="formulaDsp">
\[
       \phi(S) = \frac{w(S, V \setminus S)}{\mathrm{vol}(S)},
    \]
</p>
<p>where \(\mathrm{vol}(S) = \sum_{v \in S} \mathrm{deg}(v)\) is the volume of \(S\) and \(w(S, V \setminus S)\) is the total weight of edges crossing the cut between \(S\) and \(V \setminus S\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>a <a class="el" href="classstag_1_1graph_1_1LocalGraph.html" title="An abstract class which defines methods for exploring the local neighborhood of vertices in a graph.">stag.graph.LocalGraph</a> object representing \(G\). </td></tr>
    <tr><td class="paramname">cluster</td><td>an array of node IDs in \(S\). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the conductance \(\phi_G(S)\). </dd></dl>

</div>
</div>
<a id="a0f3375da3d31fffb4ce66f95e049d5b2" name="a0f3375da3d31fffb4ce66f95e049d5b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3375da3d31fffb4ce66f95e049d5b2">&#9670;&#160;</a></span>symmetric_difference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray stag.cluster.symmetric_difference </td>
          <td>(</td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the symmetric difference of two sets of integers. </p>
<p>Given sets \(S\) and \(T\), the symmetric difference \(S \triangle T\) is defined to be</p>
<p class="formulaDsp">
\[
        S \triangle T = \{S \setminus T\} \cup \{T \setminus S\}.
    \]
</p>
<p>Although \(S\) and \(T\) are provided as lists, they are treated as sets and any duplicates will be ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>an array containing the first set of integers </td></tr>
    <tr><td class="paramname">t</td><td>an array containing the second set of integers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an array containing the vertices in the symmetric difference of \(S\) and \(T\). </dd></dl>

</div>
</div>
<a id="a30d975a0703c35ab431dac155d897ad2" name="a30d975a0703c35ab431dac155d897ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d975a0703c35ab431dac155d897ad2">&#9670;&#160;</a></span>approximate_similarity_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classstag_1_1graph_1_1Graph.html">graph.Graph</a> stag.cluster.approximate_similarity_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1utility_1_1DenseMat.html">utility.DenseMat</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an approximate similarity graph for the given dataset. </p>
<p>Given datapoints \(\{x_1, \ldots, x_n\} \in \mathbb{R}^n\) and a parameter \(a\), the similarity between two data points is given by  </p><p class="formulaDsp">
\[
       k(x_i, x_j) = \mathrm{exp}\left(- a \|x_i - x_j\|^2 \right).
    \]
</p>
<p> Then, the similarity graph of the data is a complete graph on \(n\) vertices such that the weight between vertex \(i\) and \(j\) is given by \(k(x_i, x_j)\). However, the complete similarity graph requires \(O(n^2)\) time and space to construct.</p>
<p>This method implements an algorithm which approximates the similarity graph with a sparse graph, while preserving any cluster structure of the graph. This algorithm has running time \(\widetilde{O}(n^{1.25})\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>an \(n \times d\) matrix representing the dataset. </td></tr>
    <tr><td class="paramname">a</td><td>the parameter of the similarity kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classstag_1_1graph_1_1Graph.html" title="The core object used to represent graphs for use with the library.">stag.graph.Graph</a> object representing the similarity of the data</dd></dl>
<dl class="section user"><dt>Reference</dt><dd>Peter Macgregor and He Sun, Fast Approximation of Similarity Graphs with Kernel Density Estimation. In NeurIPS'23. </dd></dl>

</div>
</div>
<a id="a32a164cd3751f58aad7f66d21c359d93" name="a32a164cd3751f58aad7f66d21c359d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a164cd3751f58aad7f66d21c359d93">&#9670;&#160;</a></span>similarity_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classstag_1_1graph_1_1Graph.html">graph.Graph</a> stag.cluster.similarity_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classstag_1_1utility_1_1DenseMat.html">utility.DenseMat</a>&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a complete similarity graph for the given dataset. </p>
<p>Given datapoints \(\{x_1, \ldots, x_n\} \in \mathbb{R}^n\) and a parameter \(a\), the similarity between two data points is given by  </p><p class="formulaDsp">
\[
       k(x_i, x_j) = \mathrm{exp}\left(- a \|x_i - x_j\|^2 \right).
    \]
</p>
<p> Then, the similarity graph of the data is a complete graph on \(n\) vertices such that the weight between vertex \(i\) and \(j\) is given by \(k(x_i, x_j)\).</p>
<p>Note that the time and space complexity of this method is \(O(n^2)\). For a faster, approximate method, you could consider using stag::approximate_similarity_graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>an \(n \times d\) matrix representing the dataset. </td></tr>
    <tr><td class="paramname">a</td><td>the parameter of the similarity kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classstag_1_1graph_1_1Graph.html" title="The core object used to represent graphs for use with the library.">stag.graph.Graph</a> object representing the similarity of the data </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacestag.html">stag</a></li><li class="navelem"><a class="el" href="namespacestag_1_1cluster.html">cluster</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
