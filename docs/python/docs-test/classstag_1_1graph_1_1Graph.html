<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STAG Python: stag.graph.Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ginger.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">STAG Python
   &#160;<span id="projectnumber">dev</span>
   </div>
   <div id="projectbrief">Spectral Toolkit of Algorithms for Graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KJQKRESXE4"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-KJQKRESXE4');
</script>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classstag_1_1graph_1_1Graph.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classstag_1_1graph_1_1Graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">stag.graph.Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for stag.graph.Graph:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classstag_1_1graph_1_1Graph.png" usemap="#stag.graph.Graph_map" alt=""/>
  <map id="stag.graph.Graph_map" name="stag.graph.Graph_map">
<area href="classstag_1_1graph_1_1LocalGraph.html" title="An abstract class which defines methods for exploring the local neighborhood of vertices in a graph." alt="stag.graph.LocalGraph" shape="rect" coords="0,56,142,80"/>
  </map>
</div></div>
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<div class="textblock"><p>The core object used to represent graphs for use with the library. </p>
<p>Graphs are always constructed from sparse matrices, and this is the internal representation used as well. Vertices of the graph are always referred to by their unique integer index. This index corresponds to the position of the vertex in the stored adjacency matrix of the graph.</p>
<p>This class supports graphs with positive edge weights. Self-loops are permitted. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a818f486ba40f621e39784b8a49ef7bf7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#a818f486ba40f621e39784b8a49ef7bf7">__init__</a> (self, scipy.sparse.spmatrix mat, stag_internal.Graph internal_graph=None)</td></tr>
<tr class="memdesc:a818f486ba40f621e39784b8a49ef7bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the graph with a scipy sparse matrix.  <br /></td></tr>
<tr class="separator:a818f486ba40f621e39784b8a49ef7bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec5c576fe19020a621c1f61154ce1148"><td class="memItemLeft" align="right" valign="top">scipy.sparse.csc_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#aec5c576fe19020a621c1f61154ce1148">adjacency</a> (self)</td></tr>
<tr class="memdesc:aec5c576fe19020a621c1f61154ce1148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sparse adjacency matrix of the graph.  <br /></td></tr>
<tr class="separator:aec5c576fe19020a621c1f61154ce1148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba67119b1c3bd0ff504adb47d7ce72f"><td class="memItemLeft" align="right" valign="top">scipy.sparse.csc_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#a4ba67119b1c3bd0ff504adb47d7ce72f">laplacian</a> (self)</td></tr>
<tr class="memdesc:a4ba67119b1c3bd0ff504adb47d7ce72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the Laplacian matrix of the graph.  <br /></td></tr>
<tr class="separator:a4ba67119b1c3bd0ff504adb47d7ce72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1cb2b1916a67c6da01cae0f4ff029ec"><td class="memItemLeft" align="right" valign="top">scipy.sparse.csc_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#aa1cb2b1916a67c6da01cae0f4ff029ec">normalised_laplacian</a> (self)</td></tr>
<tr class="memdesc:aa1cb2b1916a67c6da01cae0f4ff029ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the normalised Laplacian matrix of the graph.  <br /></td></tr>
<tr class="separator:aa1cb2b1916a67c6da01cae0f4ff029ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1cb2b1916a67c6da01cae0f4ff029ec"><td class="memItemLeft" align="right" valign="top">scipy.sparse.csc_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#aa1cb2b1916a67c6da01cae0f4ff029ec">normalised_laplacian</a> (self)</td></tr>
<tr class="memdesc:aa1cb2b1916a67c6da01cae0f4ff029ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the normalised Laplacian matrix of the graph.  <br /></td></tr>
<tr class="separator:aa1cb2b1916a67c6da01cae0f4ff029ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4154ffe54c97573bc248ae2563e2a59"><td class="memItemLeft" align="right" valign="top">scipy.sparse.csc_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#ad4154ffe54c97573bc248ae2563e2a59">signless_laplacian</a> (self)</td></tr>
<tr class="memdesc:ad4154ffe54c97573bc248ae2563e2a59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the signless Laplacian matrix of the graph.  <br /></td></tr>
<tr class="separator:ad4154ffe54c97573bc248ae2563e2a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354b04c6caedca2c02aeb2a169e4bad2"><td class="memItemLeft" align="right" valign="top">scipy.sparse.csc_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#a354b04c6caedca2c02aeb2a169e4bad2">normalised_signless_laplacian</a> (self)</td></tr>
<tr class="memdesc:a354b04c6caedca2c02aeb2a169e4bad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the normalised signless Laplacian matrix of the graph.  <br /></td></tr>
<tr class="separator:a354b04c6caedca2c02aeb2a169e4bad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed74a7d9e6e4b2dbaa2b86da0b246a0"><td class="memItemLeft" align="right" valign="top">scipy.sparse.csc_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#aeed74a7d9e6e4b2dbaa2b86da0b246a0">degree_matrix</a> (self)</td></tr>
<tr class="memdesc:aeed74a7d9e6e4b2dbaa2b86da0b246a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The degree matrix of the graph.  <br /></td></tr>
<tr class="separator:aeed74a7d9e6e4b2dbaa2b86da0b246a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1615703382d0293acd8f992f18fdbd4"><td class="memItemLeft" align="right" valign="top">scipy.sparse.csc_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#ab1615703382d0293acd8f992f18fdbd4">inverse_degree_matrix</a> (self)</td></tr>
<tr class="memdesc:ab1615703382d0293acd8f992f18fdbd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse degree matrix of the graph.  <br /></td></tr>
<tr class="separator:ab1615703382d0293acd8f992f18fdbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3651a1a03c9c4afbe4757307b6225b63"><td class="memItemLeft" align="right" valign="top">scipy.sparse.csc_matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#a3651a1a03c9c4afbe4757307b6225b63">lazy_random_walk_matrix</a> (self)</td></tr>
<tr class="memdesc:a3651a1a03c9c4afbe4757307b6225b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lazy random walk matrix of the graph.  <br /></td></tr>
<tr class="separator:a3651a1a03c9c4afbe4757307b6225b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10aa985cc873049ff74d5fe9a4ee22a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#af10aa985cc873049ff74d5fe9a4ee22a">total_volume</a> (self)</td></tr>
<tr class="memdesc:af10aa985cc873049ff74d5fe9a4ee22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The volume of the graph.  <br /></td></tr>
<tr class="separator:af10aa985cc873049ff74d5fe9a4ee22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa46323ab2e184bb04b2b953dde383c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#aeaa46323ab2e184bb04b2b953dde383c">average_degree</a> (self)</td></tr>
<tr class="memdesc:aeaa46323ab2e184bb04b2b953dde383c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The average degree of the graph.  <br /></td></tr>
<tr class="separator:aeaa46323ab2e184bb04b2b953dde383c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865eb8ecd3e4aded5831fc7d7f90b039"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#a865eb8ecd3e4aded5831fc7d7f90b039">number_of_vertices</a> (self)</td></tr>
<tr class="memdesc:a865eb8ecd3e4aded5831fc7d7f90b039"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of vertices in the graph.  <br /></td></tr>
<tr class="separator:a865eb8ecd3e4aded5831fc7d7f90b039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306f01cc126bc93e769b3e31882e6f77"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#a306f01cc126bc93e769b3e31882e6f77">number_of_edges</a> (self)</td></tr>
<tr class="memdesc:a306f01cc126bc93e769b3e31882e6f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of edges in the graph.  <br /></td></tr>
<tr class="separator:a306f01cc126bc93e769b3e31882e6f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e3671966e292b94cb8a6e8aa424347"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#a86e3671966e292b94cb8a6e8aa424347">has_self_loops</a> (self)</td></tr>
<tr class="memdesc:a86e3671966e292b94cb8a6e8aa424347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a boolean indicating whether this graph contains self loops.  <br /></td></tr>
<tr class="separator:a86e3671966e292b94cb8a6e8aa424347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8476324f49f0cb205b96b4f845d0d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#a9f8476324f49f0cb205b96b4f845d0d1">is_connected</a> (self)</td></tr>
<tr class="memdesc:a9f8476324f49f0cb205b96b4f845d0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a boolean indicating whether the graph is connected.  <br /></td></tr>
<tr class="separator:a9f8476324f49f0cb205b96b4f845d0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48a4fafc8b134885ed2afe9309bd7c8"><td class="memItemLeft" align="right" valign="top"> '<a class="el" href="classstag_1_1graph_1_1Graph.html">Graph</a>'&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#ac48a4fafc8b134885ed2afe9309bd7c8">subgraph</a> (self, List[int] vertices)</td></tr>
<tr class="memdesc:ac48a4fafc8b134885ed2afe9309bd7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and return a subgraph of this graph.  <br /></td></tr>
<tr class="separator:ac48a4fafc8b134885ed2afe9309bd7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca6b60670d61c2f4d7253f31e0aa851"><td class="memItemLeft" align="right" valign="top"> '<a class="el" href="classstag_1_1graph_1_1Graph.html">Graph</a>'&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#adca6b60670d61c2f4d7253f31e0aa851">disjoint_union</a> (self, '<a class="el" href="classstag_1_1graph_1_1Graph.html">Graph</a>' other)</td></tr>
<tr class="memdesc:adca6b60670d61c2f4d7253f31e0aa851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and return the disjoint union of this graph and another.  <br /></td></tr>
<tr class="separator:adca6b60670d61c2f4d7253f31e0aa851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97caa37897810a0afac63c3a8159db32"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#a97caa37897810a0afac63c3a8159db32">degree</a> (self, int v)</td></tr>
<tr class="memdesc:a97caa37897810a0afac63c3a8159db32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vertex v, return its weighted degree.  <br /></td></tr>
<tr class="separator:a97caa37897810a0afac63c3a8159db32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07211431e0d1f4dcf62fbd44e26e8c9a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#a07211431e0d1f4dcf62fbd44e26e8c9a">degree_unweighted</a> (self, int v)</td></tr>
<tr class="memdesc:a07211431e0d1f4dcf62fbd44e26e8c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vertex v, return its unweighted degree.  <br /></td></tr>
<tr class="separator:a07211431e0d1f4dcf62fbd44e26e8c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461fa61297f2893e15ba395029b453ec"><td class="memItemLeft" align="right" valign="top">List[<a class="el" href="classstag_1_1graph_1_1Edge.html">Edge</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#a461fa61297f2893e15ba395029b453ec">neighbors</a> (self, int v)</td></tr>
<tr class="memdesc:a461fa61297f2893e15ba395029b453ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vertex v, return a list of edges representing the neighbors of v.  <br /></td></tr>
<tr class="separator:a461fa61297f2893e15ba395029b453ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97466e29030101fabbd4bd435213066e"><td class="memItemLeft" align="right" valign="top">List[int]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#a97466e29030101fabbd4bd435213066e">neighbors_unweighted</a> (self, int v)</td></tr>
<tr class="memdesc:a97466e29030101fabbd4bd435213066e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vertex v, return a list of neighbors of v.  <br /></td></tr>
<tr class="separator:a97466e29030101fabbd4bd435213066e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd63d87814f513aa45e6f09866663d6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#acd63d87814f513aa45e6f09866663d6f">vertex_exists</a> (self, int v)</td></tr>
<tr class="memdesc:acd63d87814f513aa45e6f09866663d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vertex ID, returns true or false to indicate whether the vertex exists in the graph.  <br /></td></tr>
<tr class="separator:acd63d87814f513aa45e6f09866663d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80036f95b1a27f52875056b79fa2a97"><td class="memItemLeft" align="right" valign="top">networkx.Graph&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#ad80036f95b1a27f52875056b79fa2a97">to_networkx</a> (self)</td></tr>
<tr class="memdesc:ad80036f95b1a27f52875056b79fa2a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a networkx graph object which is equivalent to this STAG graph.  <br /></td></tr>
<tr class="separator:ad80036f95b1a27f52875056b79fa2a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed1026242f119f4009df30e4cc6b611"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1Graph.html#a3ed1026242f119f4009df30e4cc6b611">draw</a> (self, **kwargs)</td></tr>
<tr class="memdesc:a3ed1026242f119f4009df30e4cc6b611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plot the graph with matplotlib.  <br /></td></tr>
<tr class="separator:a3ed1026242f119f4009df30e4cc6b611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classstag_1_1graph_1_1LocalGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classstag_1_1graph_1_1LocalGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classstag_1_1graph_1_1LocalGraph.html">stag.graph.LocalGraph</a></td></tr>
<tr class="memitem:a748581479b88b5ca5797a8ab8a4e58a0 inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1LocalGraph.html#a748581479b88b5ca5797a8ab8a4e58a0">__init__</a> (self)</td></tr>
<tr class="memdesc:a748581479b88b5ca5797a8ab8a4e58a0 inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default LocalGraph constructor.  <br /></td></tr>
<tr class="separator:a748581479b88b5ca5797a8ab8a4e58a0 inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766238ad6182507265004c68b535d5ce inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1LocalGraph.html#a766238ad6182507265004c68b535d5ce">degree</a> (self, int v)</td></tr>
<tr class="memdesc:a766238ad6182507265004c68b535d5ce inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vertex v, return its weighted degree.  <br /></td></tr>
<tr class="separator:a766238ad6182507265004c68b535d5ce inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ab5055293bf58d64dc049fba55df86 inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1LocalGraph.html#a68ab5055293bf58d64dc049fba55df86">degree_unweighted</a> (self, int v)</td></tr>
<tr class="memdesc:a68ab5055293bf58d64dc049fba55df86 inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vertex v, return its unweighted degree.  <br /></td></tr>
<tr class="separator:a68ab5055293bf58d64dc049fba55df86 inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97291fbf67c5b43b9a59c86b6d76201a inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="memItemLeft" align="right" valign="top">List[<a class="el" href="classstag_1_1graph_1_1Edge.html">Edge</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1LocalGraph.html#a97291fbf67c5b43b9a59c86b6d76201a">neighbors</a> (self, int v)</td></tr>
<tr class="memdesc:a97291fbf67c5b43b9a59c86b6d76201a inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vertex v, return a list of edges representing the neighbors of v.  <br /></td></tr>
<tr class="separator:a97291fbf67c5b43b9a59c86b6d76201a inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cd80a9d0c1bf530a591ab379145950 inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="memItemLeft" align="right" valign="top">List[int]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1LocalGraph.html#a08cd80a9d0c1bf530a591ab379145950">neighbors_unweighted</a> (self, int v)</td></tr>
<tr class="memdesc:a08cd80a9d0c1bf530a591ab379145950 inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vertex v, return a list of neighbors of v.  <br /></td></tr>
<tr class="separator:a08cd80a9d0c1bf530a591ab379145950 inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b10dfc22f75a0eb20d49a0ec955409 inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="memItemLeft" align="right" valign="top">List[float]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1LocalGraph.html#ab2b10dfc22f75a0eb20d49a0ec955409">degrees</a> (self, List[int] vertices)</td></tr>
<tr class="memdesc:ab2b10dfc22f75a0eb20d49a0ec955409 inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of vertices, return a list of their weighted degrees.  <br /></td></tr>
<tr class="separator:ab2b10dfc22f75a0eb20d49a0ec955409 inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07610abc6236ee6306345eea16d52bd3 inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="memItemLeft" align="right" valign="top">List[int]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1LocalGraph.html#a07610abc6236ee6306345eea16d52bd3">degrees_unweighted</a> (self, List[int] vertices)</td></tr>
<tr class="memdesc:a07610abc6236ee6306345eea16d52bd3 inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of vertices, return a list of their unweighted degrees.  <br /></td></tr>
<tr class="separator:a07610abc6236ee6306345eea16d52bd3 inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59a5e11011ac6394aa5aab6123830c6 inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstag_1_1graph_1_1LocalGraph.html#aa59a5e11011ac6394aa5aab6123830c6">vertex_exists</a> (self, int v)</td></tr>
<tr class="memdesc:aa59a5e11011ac6394aa5aab6123830c6 inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vertex ID, returns true or false to indicate whether the vertex exists in the graph.  <br /></td></tr>
<tr class="separator:aa59a5e11011ac6394aa5aab6123830c6 inherit pub_methods_classstag_1_1graph_1_1LocalGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a818f486ba40f621e39784b8a49ef7bf7" name="a818f486ba40f621e39784b8a49ef7bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818f486ba40f621e39784b8a49ef7bf7">&#9670;&#160;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def stag.graph.Graph.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scipy.sparse.spmatrix&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stag_internal.Graph &#160;</td>
          <td class="paramname"><em>internal_graph</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the graph with a scipy sparse matrix. </p>
<p>The provided matrix should correspond either to the adjacency matrix or Laplacian matrix of the graph. STAG will automatically detect whether the provided matrix is an adjacency matrix or a Laplacian matrix.</p>
<p>For example:</p>
<div class="fragment"><div class="line">&gt;&gt;&gt; <span class="keyword">import</span> <a class="code hl_namespace" href="namespacestag_1_1graph.html">stag.graph</a></div>
<div class="line">&gt;&gt;&gt; <span class="keyword">import</span> scipy.sparse</div>
<div class="line">&gt;&gt;&gt;</div>
<div class="line">&gt;&gt;&gt; adj_mat = scipy.sparse.csc_matrix([[0, 1, 1, 1],</div>
<div class="line">...                                    [1, 0, 1, 1],</div>
<div class="line">...                                    [1, 1, 0, 1],</div>
<div class="line">...                                    [1, 1, 1, 0]])</div>
<div class="line">&gt;&gt;&gt; g = <a class="code hl_class" href="classstag_1_1graph_1_1Graph.html">stag.graph.Graph</a>(adj_mat)</div>
<div class="ttc" id="aclassstag_1_1graph_1_1Graph_html"><div class="ttname"><a href="classstag_1_1graph_1_1Graph.html">stag.graph.Graph</a></div><div class="ttdoc">The core object used to represent graphs for use with the library.</div><div class="ttdef"><b>Definition:</b> graph.py:290</div></div>
<div class="ttc" id="anamespacestag_1_1graph_html"><div class="ttname"><a href="namespacestag_1_1graph.html">stag.graph</a></div><div class="ttdef"><b>Definition:</b> graph.py:1</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>A sparse scipy matrix, such as <code>scipy.sparse.csc_matrix</code>. </td></tr>
    <tr><td class="paramname">internal_graph</td><td>(optional) specify a STAG C++ graph object to initialise with. Use this only if you understand the internal workings of the STAG library. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classstag_1_1graph_1_1LocalGraph.html#a748581479b88b5ca5797a8ab8a4e58a0">stag.graph.LocalGraph</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aec5c576fe19020a621c1f61154ce1148" name="aec5c576fe19020a621c1f61154ce1148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec5c576fe19020a621c1f61154ce1148">&#9670;&#160;</a></span>adjacency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> scipy.sparse.csc_matrix stag.graph.Graph.adjacency </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the sparse adjacency matrix of the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>a <code>scipy.sparse.csc_matrix</code> representing the graph adjacency matrix </dd></dl>

</div>
</div>
<a id="a4ba67119b1c3bd0ff504adb47d7ce72f" name="a4ba67119b1c3bd0ff504adb47d7ce72f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba67119b1c3bd0ff504adb47d7ce72f">&#9670;&#160;</a></span>laplacian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> scipy.sparse.csc_matrix stag.graph.Graph.laplacian </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the Laplacian matrix of the graph. </p>
<p>The Laplacian matrix is defined by</p>
<p class="formulaDsp">
\[
        L = D - A
    \]
</p>
<p>where \(D\) is the diagonal matrix of vertex degrees and \(A\) is the adjacency matrix of the graph.</p>
<dl class="section return"><dt>Returns</dt><dd>a <code>scipy.sparse.csc_matrix</code> representing the graph Laplacian </dd></dl>

</div>
</div>
<a id="aa1cb2b1916a67c6da01cae0f4ff029ec" name="aa1cb2b1916a67c6da01cae0f4ff029ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1cb2b1916a67c6da01cae0f4ff029ec">&#9670;&#160;</a></span>normalised_laplacian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> scipy.sparse.csc_matrix stag.graph.Graph.normalised_laplacian </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the normalised Laplacian matrix of the graph. </p>
<p>The normalised Laplacian matrix is defined by</p>
<p class="formulaDsp">
\[
        \mathcal{L} = D^{-1/2} L D^{-1/2}
    \]
</p>
<p>where \(D\) is the diagonal matrix of vertex degrees and \(L\) is the Laplacian matrix of the graph.</p>
<dl class="section return"><dt>Returns</dt><dd>a <code>scipy.sparse.csc_matrix</code> representing the normalised Laplacian </dd></dl>

</div>
</div>
<a id="aa1cb2b1916a67c6da01cae0f4ff029ec" name="aa1cb2b1916a67c6da01cae0f4ff029ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1cb2b1916a67c6da01cae0f4ff029ec">&#9670;&#160;</a></span>normalised_laplacian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> scipy.sparse.csc_matrix stag.graph.Graph.normalised_laplacian </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the normalised Laplacian matrix of the graph. </p>
<p>The normalised Laplacian matrix is defined by</p>
<p class="formulaDsp">
\[
        \mathcal{L} = D^{-1/2} L D^{-1/2}
    \]
</p>
<p>where \(D\) is the diagonal matrix of vertex degrees and \(L\) is the Laplacian matrix of the graph.</p>
<dl class="section return"><dt>Returns</dt><dd>a <code>scipy.sparse.csc_matrix</code> representing the normalised Laplacian </dd></dl>

</div>
</div>
<a id="ad4154ffe54c97573bc248ae2563e2a59" name="ad4154ffe54c97573bc248ae2563e2a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4154ffe54c97573bc248ae2563e2a59">&#9670;&#160;</a></span>signless_laplacian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> scipy.sparse.csc_matrix stag.graph.Graph.signless_laplacian </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the signless Laplacian matrix of the graph. </p>
<p>The signless Laplacian matrix is defined by</p>
<p class="formulaDsp">
\[
        J = D + A
    \]
</p>
<p>where \(D\) is the diagonal matrix of vertex degrees and \(A\) is the adjacency matrix of the graph.</p>
<dl class="section return"><dt>Returns</dt><dd>a <code>scipy.sparse.csc_matrix</code> representing the signless graph Laplacian </dd></dl>

</div>
</div>
<a id="a354b04c6caedca2c02aeb2a169e4bad2" name="a354b04c6caedca2c02aeb2a169e4bad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354b04c6caedca2c02aeb2a169e4bad2">&#9670;&#160;</a></span>normalised_signless_laplacian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> scipy.sparse.csc_matrix stag.graph.Graph.normalised_signless_laplacian </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the normalised signless Laplacian matrix of the graph. </p>
<p>The normalised signless Laplacian matrix is defined by</p>
<p class="formulaDsp">
\[
        \mathcal{J} = D^{-1/2} J D^{-1/2}
    \]
</p>
<p>where \(D\) is the diagonal matrix of vertex degrees and \(J\) is the signless Laplacian matrix of the graph.</p>
<dl class="section return"><dt>Returns</dt><dd>a <code>scipy.sparse.csc_matrix</code> representing the normalised signless Laplacian </dd></dl>

</div>
</div>
<a id="aeed74a7d9e6e4b2dbaa2b86da0b246a0" name="aeed74a7d9e6e4b2dbaa2b86da0b246a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeed74a7d9e6e4b2dbaa2b86da0b246a0">&#9670;&#160;</a></span>degree_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> scipy.sparse.csc_matrix stag.graph.Graph.degree_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The degree matrix of the graph. </p>
<p>The degree matrix \(D \in \mathbb{R}^{n \\times n}\) is a diagonal matrix such that \(D(i, i) = \mathrm{deg}(i)\) where \(\mathrm{deg}(i)\) is the degree of vertex \(i\) and \(n\) is the number of vertices in the graph.</p>
<dl class="section return"><dt>Returns</dt><dd>a <code>scipy.sparse.csc_matrix</code> representing the degree matrix </dd></dl>

</div>
</div>
<a id="ab1615703382d0293acd8f992f18fdbd4" name="ab1615703382d0293acd8f992f18fdbd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1615703382d0293acd8f992f18fdbd4">&#9670;&#160;</a></span>inverse_degree_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> scipy.sparse.csc_matrix stag.graph.Graph.inverse_degree_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The inverse degree matrix of the graph. </p>
<p>The degree matrix \(D^{-1} \in \mathbb{R}^{n \times n}\) is a diagonal matrix such that</p>
<p class="formulaDsp">
\[
        D(i, i) =  \left\{
                \begin{array}{lll}
                    \mathrm{deg}(i) &amp; \mbox{if } \mathrm{deg}(i) &gt; 0 \\
                    0 &amp; \mbox{otherwise}
                \end{array}
            \right.
    \]
</p>
<p>where \(\mathrm{deg}(i)\) is the degree of vertex \(i\) and \(n\) is the number of vertices in the graph.</p>
<dl class="section return"><dt>Returns</dt><dd>a <code>scipy.sparse.csc_matrix</code> representing the inverse degree matrix </dd></dl>

</div>
</div>
<a id="a3651a1a03c9c4afbe4757307b6225b63" name="a3651a1a03c9c4afbe4757307b6225b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3651a1a03c9c4afbe4757307b6225b63">&#9670;&#160;</a></span>lazy_random_walk_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> scipy.sparse.csc_matrix stag.graph.Graph.lazy_random_walk_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The lazy random walk matrix of the graph. </p>
<p>The lazy random walk matrix is defined by</p>
<p class="formulaDsp">
\[
        W = \frac 1 2 I + \frac 1 2 A D^{-1}
    \]
</p>
<p>where \(I\) is the identity matrix, \(A\) is the graph adjacency matrix and \(D\) is the degree matrix of the graph.</p>
<dl class="section return"><dt>Returns</dt><dd>a <code>scipy.sparse.csc_matrix</code> representing the lazy random walk matrix </dd></dl>

</div>
</div>
<a id="af10aa985cc873049ff74d5fe9a4ee22a" name="af10aa985cc873049ff74d5fe9a4ee22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10aa985cc873049ff74d5fe9a4ee22a">&#9670;&#160;</a></span>total_volume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> float stag.graph.Graph.total_volume </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The volume of the graph. </p>
<p>The volume of a graph \(G = (V, E, w)\) is defined by</p>
<p class="formulaDsp">
\[
        \mathrm{vol}(G) = \sum_{u \in V} \mathrm{deg}(u),
    \]
</p>
<p>where \(\mathrm{deg}(u)\) is the degree of vertex \(u\).</p>
<dl class="section return"><dt>Returns</dt><dd>the graph's volume, \(\mathrm{vol}(G)\) </dd></dl>

</div>
</div>
<a id="aeaa46323ab2e184bb04b2b953dde383c" name="aeaa46323ab2e184bb04b2b953dde383c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa46323ab2e184bb04b2b953dde383c">&#9670;&#160;</a></span>average_degree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> float stag.graph.Graph.average_degree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The average degree of the graph. </p>
<p>This is defined as the sum of the node degrees divided by the number of nodes.</p>
<dl class="section return"><dt>Returns</dt><dd>the graph's average degree. </dd></dl>

</div>
</div>
<a id="a865eb8ecd3e4aded5831fc7d7f90b039" name="a865eb8ecd3e4aded5831fc7d7f90b039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865eb8ecd3e4aded5831fc7d7f90b039">&#9670;&#160;</a></span>number_of_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int stag.graph.Graph.number_of_vertices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of vertices in the graph. </p>

</div>
</div>
<a id="a306f01cc126bc93e769b3e31882e6f77" name="a306f01cc126bc93e769b3e31882e6f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306f01cc126bc93e769b3e31882e6f77">&#9670;&#160;</a></span>number_of_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int stag.graph.Graph.number_of_edges </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of edges in the graph. </p>
<p>This method ignores the weights of the edges. </p>

</div>
</div>
<a id="a86e3671966e292b94cb8a6e8aa424347" name="a86e3671966e292b94cb8a6e8aa424347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e3671966e292b94cb8a6e8aa424347">&#9670;&#160;</a></span>has_self_loops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool stag.graph.Graph.has_self_loops </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a boolean indicating whether this graph contains self loops. </p>

</div>
</div>
<a id="a9f8476324f49f0cb205b96b4f845d0d1" name="a9f8476324f49f0cb205b96b4f845d0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8476324f49f0cb205b96b4f845d0d1">&#9670;&#160;</a></span>is_connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool stag.graph.Graph.is_connected </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a boolean indicating whether the graph is connected. </p>
<p>The running time of this method is \(O(m)\) where \(m\) is the number of edges in the graph. </p>

</div>
</div>
<a id="ac48a4fafc8b134885ed2afe9309bd7c8" name="ac48a4fafc8b134885ed2afe9309bd7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48a4fafc8b134885ed2afe9309bd7c8">&#9670;&#160;</a></span>subgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> '<a class="el" href="classstag_1_1graph_1_1Graph.html">Graph</a>' stag.graph.Graph.subgraph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">List[int]&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct and return a subgraph of this graph. </p>
<p>Note that the vertex indices will be changed in the subgraph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>the vertices in the induced subgraph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="classstag_1_1graph_1_1Graph.html" title="The core object used to represent graphs for use with the library.">stag.graph.Graph</a> object representing the subgraph induced by the given vertices </dd></dl>

</div>
</div>
<a id="adca6b60670d61c2f4d7253f31e0aa851" name="adca6b60670d61c2f4d7253f31e0aa851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca6b60670d61c2f4d7253f31e0aa851">&#9670;&#160;</a></span>disjoint_union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> '<a class="el" href="classstag_1_1graph_1_1Graph.html">Graph</a>' stag.graph.Graph.disjoint_union </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">'<a class="el" href="classstag_1_1graph_1_1Graph.html">Graph</a>'&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct and return the disjoint union of this graph and another. </p>
<p>The disjoint union of two graphs \(G\) and \(H\) is a graph containing \(G\) and \(H\) as disconnected subgraphs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other graph to be combined with this one </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new <a class="el" href="classstag_1_1graph_1_1Graph.html" title="The core object used to represent graphs for use with the library.">stag.graph.Graph</a> object representing the union of this graph with the other one </dd></dl>

</div>
</div>
<a id="a97caa37897810a0afac63c3a8159db32" name="a97caa37897810a0afac63c3a8159db32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97caa37897810a0afac63c3a8159db32">&#9670;&#160;</a></span>degree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> float stag.graph.Graph.degree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vertex v, return its weighted degree. </p>

<p>Reimplemented from <a class="el" href="classstag_1_1graph_1_1LocalGraph.html#a766238ad6182507265004c68b535d5ce">stag.graph.LocalGraph</a>.</p>

</div>
</div>
<a id="a07211431e0d1f4dcf62fbd44e26e8c9a" name="a07211431e0d1f4dcf62fbd44e26e8c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07211431e0d1f4dcf62fbd44e26e8c9a">&#9670;&#160;</a></span>degree_unweighted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int stag.graph.Graph.degree_unweighted </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vertex v, return its unweighted degree. </p>
<p>That is, the number of neighbors of v, ignoring the edge weights. </p>

<p>Reimplemented from <a class="el" href="classstag_1_1graph_1_1LocalGraph.html#a68ab5055293bf58d64dc049fba55df86">stag.graph.LocalGraph</a>.</p>

</div>
</div>
<a id="a461fa61297f2893e15ba395029b453ec" name="a461fa61297f2893e15ba395029b453ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461fa61297f2893e15ba395029b453ec">&#9670;&#160;</a></span>neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[<a class="el" href="classstag_1_1graph_1_1Edge.html">Edge</a>] stag.graph.Graph.neighbors </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vertex v, return a list of edges representing the neighbors of v. </p>
<p>The returned edge objects will all have the ordering <code>(v1, v2)</code> such that <code>edge.v1 = v</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the ID of some vertex in the graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of <a class="el" href="classstag_1_1graph_1_1Edge.html" title="An object representing a weighted edge in a graph.">stag.graph.Edge</a> objects containing the neighbourhood of v </dd></dl>

<p>Reimplemented from <a class="el" href="classstag_1_1graph_1_1LocalGraph.html#a97291fbf67c5b43b9a59c86b6d76201a">stag.graph.LocalGraph</a>.</p>

</div>
</div>
<a id="a97466e29030101fabbd4bd435213066e" name="a97466e29030101fabbd4bd435213066e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97466e29030101fabbd4bd435213066e">&#9670;&#160;</a></span>neighbors_unweighted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> List[int] stag.graph.Graph.neighbors_unweighted </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vertex v, return a list of neighbors of v. </p>
<p>The weights of edges to the neighbors are not returned by this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the ID of some vertex in the graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of vertex IDs giving the neighbours of v </dd></dl>

<p>Reimplemented from <a class="el" href="classstag_1_1graph_1_1LocalGraph.html#a08cd80a9d0c1bf530a591ab379145950">stag.graph.LocalGraph</a>.</p>

</div>
</div>
<a id="acd63d87814f513aa45e6f09866663d6f" name="acd63d87814f513aa45e6f09866663d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd63d87814f513aa45e6f09866663d6f">&#9670;&#160;</a></span>vertex_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool stag.graph.Graph.vertex_exists </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a vertex ID, returns true or false to indicate whether the vertex exists in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the vertex index to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a boolean indicating whether there exists a vertex with the given index </dd></dl>

<p>Reimplemented from <a class="el" href="classstag_1_1graph_1_1LocalGraph.html#aa59a5e11011ac6394aa5aab6123830c6">stag.graph.LocalGraph</a>.</p>

</div>
</div>
<a id="ad80036f95b1a27f52875056b79fa2a97" name="ad80036f95b1a27f52875056b79fa2a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80036f95b1a27f52875056b79fa2a97">&#9670;&#160;</a></span>to_networkx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> networkx.Graph stag.graph.Graph.to_networkx </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a networkx graph object which is equivalent to this STAG graph. </p>
<p>See the <a href="https://networkx.org/documentation/stable/reference/classes/graph.html">networkx documentation</a>. </p>

</div>
</div>
<a id="a3ed1026242f119f4009df30e4cc6b611" name="a3ed1026242f119f4009df30e4cc6b611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed1026242f119f4009df30e4cc6b611">&#9670;&#160;</a></span>draw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def stag.graph.Graph.draw </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Plot the graph with matplotlib. </p>
<p>This uses the networkx draw method and accepts any the keyword arguments will be passed through directly.</p>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<div class="fragment"><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div>
<div class="line"><span class="keyword">import</span> <a class="code hl_namespace" href="namespacestag_1_1graph.html">stag.graph</a></div>
<div class="line">myGraph = <a class="code hl_function" href="namespacestag_1_1graph.html#ae1faea33014d4ea2fdfe692a3dbb2863">stag.graph.star_graph</a>(10)</div>
<div class="line">myGraph.draw()</div>
<div class="line">plt.show()</div>
<div class="ttc" id="anamespacestag_1_1graph_html_ae1faea33014d4ea2fdfe692a3dbb2863"><div class="ttname"><a href="namespacestag_1_1graph.html#ae1faea33014d4ea2fdfe692a3dbb2863">stag.graph.star_graph</a></div><div class="ttdeci">Graph star_graph(n)</div><div class="ttdoc">Construct a star graph.</div><div class="ttdef"><b>Definition:</b> graph.py:742</div></div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacestag.html">stag</a></li><li class="navelem"><a class="el" href="namespacestag_1_1graph.html">graph</a></li><li class="navelem"><a class="el" href="classstag_1_1graph_1_1Graph.html">Graph</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
